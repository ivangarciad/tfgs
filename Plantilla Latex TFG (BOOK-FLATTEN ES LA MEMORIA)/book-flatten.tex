




\documentclass[spanish,openright]{book}

\makeatletter{}

\usepackage[x11names,table]{xcolor}

\usepackage{ifthen}

\newcommand{\colorspaceused}{rgb}

\ifthenelse{\equal{\colorspaceused}{rgb}}
{
  \PassOptionsToPackage{rgb}{xcolor}}
{
  \PassOptionsToPackage{cmyk}{xcolor}}

\usepackage[latin1]{inputenc} \usepackage[T1]{fontenc}                            
\usepackage{ae}              
\usepackage{lmodern}                                        
\usepackage[spanish, english]{babel}

\usepackage[final]{pdfpages}

\usepackage{emptypage}


\usepackage{tabu}
\usepackage{booktabs}

\usepackage{multicol}

\usepackage{rotating}

\usepackage[nottoc,numbib]{tocbibind}

\usepackage{tocbibind}

\usepackage{animate}

\usepackage{tabularx}

\usepackage{eurosym}

\usepackage[hypcap]{caption}

\usepackage{wrapfig} %Figuras al lado de texto

\usepackage[rflt]{floatflt}

\usepackage{graphicx}

\usepackage{listings}
\usepackage{longtable}
\usepackage{afterpage}

\usepackage{titlesec} \titleformat{\part}[frame]{\normalfont} %
{\filright\footnotesize\enspace CAPITULO \thepart\enspace}%
{8pt}{\Large\bfseries\filcenter} % %-

\usepackage{xspace}
\usepackage{verbatim}
\usepackage{moreverb}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{eurosym}
\usepackage{multirow}
\usepackage{fancyhdr}
\usepackage{makeidx}
\usepackage{rotating}
\usepackage{supertabular}
\usepackage{hhline}
\usepackage{array}
\usepackage[noadjust]{cite}      

\usepackage[center]{caption}
	             \usepackage{subcaption}

\usepackage{xcolor}


\definecolor{pantone293}{RGB}{35,91,168}

\definecolor{headingPortadaTFG}{RGB}{152,118,52}
\definecolor{headingPortadaTFM}{RGB}{0,90,170}
\definecolor{textoHeadingPortadaTFM}{RGB}{208,205,102}
\definecolor{textoHeadingPortadaTFG}{RGB}{208,205,102}

\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}	





\usepackage{tikz}



\usepackage{geometry}
\geometry{verbose,a4paper,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}


\usepackage[
bookmarks=true,bookmarksnumbered=true,            hypertexnames=false,               breaklinks=true,                   linktoc=all,
colorlinks=true,
linkcolor=blue,    
citecolor=green,
urlcolor=blue,                     pdfborder={0 0 112.0},              hyperfootnotes=false,
]{hyperref}                        
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\setcounter{table}{1}
\setcounter{figure}{1}
\setcounter{secnumdepth}{4}


\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}


\usepackage{multirow}

\usepackage{setspace}
\newcommand{\mycaptiontable}[1]{
  \begin{spacing}{0.6}
        \begin{quote}
            {{Table} \thechapter.\arabic{table}: #1}
          \end{quote}
      \end{spacing}
  \stepcounter{table}
}

\newcommand{\mycaptionfigure}[1]{
    \begin{spacing}{0.6}
    \begin{quote}
            {{Figure} \thechapter.\arabic{figure}: #1}
          \end{quote}
      \end{spacing}
  \stepcounter{figure}
}

\usepackage{amsmath}

\usepackage{courier}

\usepackage{multirow}
\usepackage{rotating}
\usepackage{setspace, amssymb, amsmath, epsfig, multirow, colortbl, tabularx}
\usepackage[acronym,shortcuts,nomain,hyperfirst=false]{glossaries}


\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}}

\pagestyle{fancy}

\providecommand\phantomsection{}
\onehalfspacing
\sloppy  
\renewcommand{\chaptermark}[1]{\markboth{\chaptername\ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}{}}

\fancyhf{}

\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}

\makeatletter
\renewcommand{\chaptermark}[1]{\markboth{\@chapapp \ \thechapter . \ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ \ #1}}
\makeatother

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{3.5pt}
\fancypagestyle{plain}{\fancyhead{}\renewcommand{\headrulewidth}{0pt}}
\fancypagestyle{myplain}
{
  \fancyhf{}
  \renewcommand\headrulewidth{0pt}
  \renewcommand\footrulewidth{0pt}
  \fancyfoot[C]{\thepage}
}









\usepackage[pages=some]{sty/background}

\ifthenelse{\equal{\colorspaceused}{rgb}}
{
  \backgroundsetup{ scale=1, angle=0, opacity=.1, color=pink,
    contents={\includegraphics[width=.7\paperwidth]{logos/logoEPS-UAH.jpg}}, vshift=-50pt,  hshift=0pt }
}
{
  \backgroundsetup{ scale=1, angle=0, opacity=.1, color=pink,
    contents={\includegraphics[width=.7\paperwidth]{logos/logoEPS-UAH-cmyk.jpg}}, vshift=-50pt,  hshift=0pt }
}


\makeatletter
\newcommand*{\cleartoleftpage}{  \clearpage
  \if@twoside
  \ifodd\c@page
  \hbox{}\newpage
  \if@twocolumn
  \hbox{}\newpage
  \fi
  \fi
  \fi
}
\makeatother

\usepackage{float}
\floatstyle{plaintop} \newfloat{codefloat}{H}{cod}[chapter]

\lstdefinestyle{console}
{
  basicstyle=\scriptsize\bf\ttfamily,
  backgroundcolor=\color{gray75},
}

\lstdefinestyle{Cbluebox}
{
  language=C,
  frame=shadowbox, 
  rulesepcolor=\color{blue}
}

\lstdefinestyle{Cnice}
{
  language=C,
  frame=Ltb,
  framerule=0pt,
  tabsize=2,
  aboveskip=0.5cm,
  framextopmargin=3pt,
  framexbottommargin=3pt,
  framexleftmargin=0.4cm,
  framesep=0pt,
  rulesep=.4pt,
  backgroundcolor=\color{gray97},
  rulesepcolor=\color{black},
    stringstyle=\ttfamily,
  showstringspaces = false,
    basicstyle=\footnotesize\ttfamily,
  commentstyle=\color{gray45},
  keywordstyle=\bfseries,
    numbers=left,
  numbersep=15pt,
  numberstyle=\tiny,
  numberfirstline = false,
  breaklines=true,
}	

\lstdefinestyle{CppExample}
{
  language=C++,
  frame=trbl,
  tabsize=2,
  commentstyle=\textit,
  stringstyle=\ttfamily, 
  basicstyle=\small,
}	

\lstdefinestyle{Ccolor}
{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstdefinestyle{BashInputStyle}{
  language=bash,
  basicstyle=\small\sffamily,
  numbers=left,
  numberstyle=\tiny,
  numbersep=3pt,
  frame=tb, 
  showspaces=false, 
  showtabs=false,
  showstringspaces=false,
  columns=fullflexible,
  backgroundcolor=\color{gray97},
    linewidth=0.9\linewidth,
  xleftmargin=0.05\linewidth
}


\usepackage{sidecap}

\def\texis{\TeX \raise.15em\hbox{\textsc{i}}S}
\newenvironment{FraseCelebre}{\begin{list}{}{      \setlength{\leftmargin}{0.5\textwidth}                              \setlength{\parsep}{0cm}                  \addtolength{\topsep}{0.5cm}                }
  }
  {\unskip \end{list}}

\newenvironment{Frase}{\item \begin{flushright}\small\em}  {\end{flushright}}

\newenvironment{Fuente}{\item \begin{flushright}\small}  {\end{flushright}}


\newenvironment{bottomparagraph}{\par\vspace*{\fill}}{\clearpage}

\usepackage[vlined,algochapter]{algorithm2e}
\providecommand{\DontPrintSemicolon}{\dontprintsemicolon}
\providecommand{\SetAlgoLined}{\SetLine}



\usepackage{fix-cm}

\usepackage{graphicx}                                                                      


\newcommand{\myreferencespath}{}


\providecommand{\DIFadd}[1]{{\protect\color{blue}\textbf{#1}}}
\providecommand{\DIFdel}[1]{{\protect\color{red}\sout{#1}}}                     


\renewcommand{\lstlistingname}{Code}
     
                                                                  
\makeatletter{}


\newcommand{\mybooklanguage}{spanish}

\newcommand{\mydegree}{GIEAI}

\newcommand{\mybooktitle}{Análisis de unidades inerciales de medida (IMU) y diseño de controlador de ángulo de ataque aplicado a cuadricóptero}
\newcommand{\mybookauthor}{Sergio Martín Gómez}
\newcommand{\mybookdepartment}{Departamento de automática}
\newcommand{\mybookdepartmentEnglish}{Departament of Automatic}

\newcommand{\mybookschool}{Escuela Politécnica Superior}
\newcommand{\mybookuniversity}{Universidad de Alcalá}
\newcommand{\mybookuniversityacronym}{UAH}
 \newcommand{\mybookemail}{sergio.martingomez@edu.uah.es}
\newcommand{\mybookNameFirstAdvisor}{D. Iván García Daza}
\newcommand{\mybookNameSecondAdvisor}{}
\newcommand{\mybookpresident}{D. David Fernández Llorca}
\newcommand{\mybookfirstvocal}{D. Ignacio Parra Alonso}
\newcommand{\mybooksecondvocal}{D. Iván García Daza}
\newcommand{\mybooksecretary}{Name of the secretary (if needed)}
\newcommand{\mybookyear}{2015}
\newcommand{\myanteproyectodate}{6 de enero de 2014}
\newcommand{\mydefensedate}{6 de enero de 2014}
\newcommand{\mydefensedateEnglish}{January 6\textsuperscript{th}, 2014}
\newcommand{\mybookkeywords}{IMU, ESC, Arduino, Gyroscope, Accelerometer} \newcommand{\mybookpalabrasclave}{IMU, ESC, Arduino, Giróscopo, Acelerómetro } 
\newcommand{\mybookdepartmentsecretary}{José Luis Martín Sánchez}
\newcommand{\mybookdateforpaperwork}{30 de septiembre de 2014}
\newcommand{\mybookDNIOpenPublishing}{12345678-L}                                 \newcommand{\mybookDNIFirstAdvisor}{11111111-A}
\newcommand{\mybookDNISecondAdvisor}{}
\newcommand{\mybookFigure}{alumno}                                                                                                 
\newcommand{\mybookresearchreportID}{RR-2014-01}

\newcommand{\mytoclinkcolor}{black}
\newcommand{\myloflinkcolor}{black}
\newcommand{\mylotlinkcolor}{black}

\newcommand{\myothertoclinkcolor}{black}

\newcommand{\mylinkcolor}{black}

\newcommand{\myurlcolor}{black}
\newcommand{\mycitecolor}{black}



\newcommand{\myreferences}{biblio/biblio}



\DeclareRobustCommand{\texten}[1]{\textit{#1}}

\def\ci{\perp\!\!\!\perp}

\newcommand{\circulo}{\large $\circ$}
\newcommand{\asterisco}{$\ast$}
\newcommand{\cuadrado}{\tiny $\square$}
\newcommand{\triangulo}{\scriptsize $\vartriangle$}
\newcommand{\triangv}{\scriptsize $\triangledown$}
\newcommand{\diamante}{\large $\diamond$}

\newcommand{\new}[1]{\textcolor{magenta}{#1 }}
\newcommand{\argmax}[1]{\underset{#1}{\operatorname{argmax}}}

\newcommand{\verticalSpacingSRPMaps}{-0.3cm}




     
                                                                                                                                                                                                                                                        
\makeatletter{}

\newglossary[slg]{symbols}{sym}{sbl}{List of Symbols}

\makeglossaries               



   

\makeatletter{}

\ifthenelse{\equal{\mybooklanguage}{spanish}}
{
\newcommand{\mybookFullAffiliation}{Grupo de investigación \mybookresearchgroup \\ \mybookdepartment \\ \mybookuniversity} 
} 
{
\newcommand{\mybookFullAffiliation}{\mybookresearchgroup Research Group \\ \mybookdepartmentEnglish \\ \mybookuniversity} 
}

\ifthenelse{\equal{\mybookNameSecondAdvisor}{}}
{
\newcommand{\mybookadvisors}{\mybookNameFirstAdvisor{}}
\newcommand{\mybookDirectorOrDirectores}{director}
\newcommand{\mybookAdvisorOrAdvisors}{advisor}
\newcommand{\mybookDaOrDan}{da}
\newcommand{\mybookTutorOrTutores}{tutor}
\newcommand{\mybookElOrLos}{El}
\newcommand{\mybookSuOrSus}{su}
\newcommand{\mybookDelOrDeLos}{del}
}
{
\newcommand{\mybookadvisors}{\mybookNameFirstAdvisor{} y \mybookNameSecondAdvisor{}}
\newcommand{\mybookDirectorOrDirectores}{directores}
\newcommand{\mybookAdvisorOrAdvisors}{advisors}
\newcommand{\mybookDaOrDan}{dan}
\newcommand{\mybookTutorOrTutores}{tutores}
\newcommand{\mybookElOrLos}{Los}
\newcommand{\mybookSuOrSus}{Su}
\newcommand{\mybookDelOrDeLos}{de los}
}

\ifthenelse{\equal{\mydegree}{IT}}
{
  \newcommand{\mydegreefull}{Ingeniería de Telecomunicación}
  \newcommand{\mybookworktype}{TFC}
  \ifthenelse{\equal{\mybooklanguage}{spanish}}
  {
    \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
  }
  {
            \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
  }
}
{
  \ifthenelse{\equal{\mydegree}{IE}}
  {
    \newcommand{\mydegreefull}{Ingeniería Electrónica}
    \newcommand{\mybookworktype}{TFC}
    \ifthenelse{\equal{\mybooklanguage}{spanish}}
    {
      \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
    }
    {
                  \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
    }
  }
  {
    \ifthenelse{\equal{\mydegree}{ITTSE}}
    {
      \newcommand{\mydegreefull}{Ingeniería Técnica de Telecomunicación, especialidad en Sistemas Electrónicos}
      \newcommand{\mybookworktype}{TFC}
      \ifthenelse{\equal{\mybooklanguage}{spanish}}
      {
        \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
      }
      {
                        \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
      }
    }
    {
      \ifthenelse{\equal{\mydegree}{ITTST}}
      {
        \newcommand{\mydegreefull}{Ingeniería Técnica de Telecomunicación, especialidad en Sistemas de Telecomunicación}
      \newcommand{\mybookworktype}{TFC}
        \ifthenelse{\equal{\mybooklanguage}{spanish}}
        {
          \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
        }
        {
                              \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
        }
      }
      {
        \ifthenelse{\equal{\mydegree}{ITI}}
        {
          \newcommand{\mydegreefull}{Ingeniería Técnica Industrial, especialidad en Electrónica Industrial}
          \newcommand{\mybookworktype}{TFC}
          \ifthenelse{\equal{\mybooklanguage}{spanish}}
          {
            \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
          }
          {
                                    \newcommand{\mybookworktypefull}{Trabajo Fin de Carrera}
          }
        }
        {
          \ifthenelse{\equal{\mydegree}{GIEC}}
          {
            \newcommand{\mydegreefull}{Grado en Ingeniería Electrónica de Comunicaciones}
            \newcommand{\mybookworktype}{TFG}
            \ifthenelse{\equal{\mybooklanguage}{spanish}}
            {
              \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
            }
            {
                                          \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
            }
          }
          {
            \ifthenelse{\equal{\mydegree}{GIEAI}}
            {
              \newcommand{\mydegreefull}{Grado en Ingeniería en Electrónica y Automática Industrial}
              \newcommand{\mybookworktype}{TFG}
              \ifthenelse{\equal{\mybooklanguage}{spanish}}
              {
                \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
              }
              {
                                                \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
              }
            }
            {
              \ifthenelse{\equal{\mydegree}{GIST}}
              {
                \newcommand{\mydegreefull}{Grado en Ingeniería en Sistemas de Telecomunicación}
                \newcommand{\mybookworktype}{TFG}
                \ifthenelse{\equal{\mybooklanguage}{spanish}}
                {
                  \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                }
                {
                                                      \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                }
              }
              {
                \ifthenelse{\equal{\mydegree}{GITT}}
                {
                  \newcommand{\mydegreefull}{Grado en Ingeniería en Tecnologías de la Telecomunicación}
                  \newcommand{\mybookworktype}{TFG}
                  \ifthenelse{\equal{\mybooklanguage}{spanish}}
                  {
                    \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                  }
                  {
                                                            \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                  }
                }
                {
                  \ifthenelse{\equal{\mydegree}{GIT}}
                  {
                    \newcommand{\mydegreefull}{Grado en Ingeniería Telemática}
                    \newcommand{\mybookworktype}{TFG}
                    \ifthenelse{\equal{\mybooklanguage}{spanish}}
                    {
                      \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                    }
                    {
                                                                  \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                    }
                  }
                  {
                    \ifthenelse{\equal{\mydegree}{GIC}}
                    {
                      \newcommand{\mydegreefull}{Grado en Ingeniería de Computadores}
                      \newcommand{\mybookworktype}{TFG}
                      \ifthenelse{\equal{\mybooklanguage}{spanish}}
                      {
                        \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                      }
                      {
                                                                        \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                      }
                    }
                    {
                      \ifthenelse{\equal{\mydegree}{GII}}
                      {
                        \newcommand{\mydegreefull}{Grado en Ingeniería Informática}
                        \newcommand{\mybookworktype}{TFG}
                        \ifthenelse{\equal{\mybooklanguage}{spanish}}
                        {
                          \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                        }
                        {
                                                                              \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                        }
                      }
                      {
                        \ifthenelse{\equal{\mydegree}{GSI}}
                        {
                          \newcommand{\mydegreefull}{Grado en Sistemas de Información}
                          \newcommand{\mybookworktype}{TFG}
                          \ifthenelse{\equal{\mybooklanguage}{spanish}}
                          {
                            \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                          }
                          {
                                                                                    \newcommand{\mybookworktypefull}{Trabajo Fin de Grado}
                          }
                        }
                        {
                          \ifthenelse{\equal{\mydegree}{MUSEA}}
                          {
                            \newcommand{\mydegreefull}{Máster Universitario en Sistemas Electrónicos Avanzados. Sistemas Inteligentes}
                            \newcommand{\mydegreefullwrapped}{Máster Universitario en Sistemas Electrónicos Avanzados\\Sistemas Inteligentes}
                            \newcommand{\mybookworktype}{TFM}
                            \ifthenelse{\equal{\mybooklanguage}{spanish}}
                            {
                              \newcommand{\mybookworktypefull}{Trabajo Fin de Máster}
                            }
                            {
                                                                                          \newcommand{\mybookworktypefull}{Trabajo Fin de Máster}
                            }
                          }
                          {
                            \ifthenelse{\equal{\mydegree}{PHDUAH}}
                            {
                              \newcommand{\mydegreefull}{Estudios de Doctorado}
                              \newcommand{\mybookworktype}{PHDUAH}
                              \ifthenelse{\equal{\mybooklanguage}{spanish}}
                              {
                                \newcommand{\mybookworktypefull}{Tesis Doctoral}
                              }
                              {
                                \newcommand{\mybookworktypefull}{Doctoral Thesis}
                              }
                            }
                            {
                              \ifthenelse{\equal{\mydegree}{PHDUPM}}
                              {
                                \newcommand{\mydegreefull}{Doctor Ingeniero de Telecomunicación}
                                \newcommand{\mybookworktype}{PHDUPM}
                                \ifthenelse{\equal{\mybooklanguage}{spanish}}
                                {
                                  \newcommand{\mybookworktypefull}{Tesis Doctoral}
                                }
                                {
                                  \newcommand{\mybookworktypefull}{Doctoral Thesis}
                                }
                              }
                              {
                                \ifthenelse{\equal{\mydegree}{GEINTRARR}}
                                {
                                  \newcommand{\mydegreefull}{GEINTRA Research Report}
                                  \newcommand{\mybookworktype}{GEINTRARR}
                                  \ifthenelse{\equal{\mybooklanguage}{spanish}}
                                  {
                                    \newcommand{\mybookworktypefull}{Informe técnico del Grupo de investigación \mybookresearchgroup{}}
                                  }
                                  {
                                    \newcommand{\mybookworktypefull}{\mybookresearchgroup{} Research Report}
                                  }
                                }
                                {
                                  \newcommand{\mybookworktype}{TFG}
                                  \newcommand{\mydegreefull}{ERROR: Defined degree (\mydegree) unknown, check \texttt{config/myconfig.tex}} 
                                  \newcommand{\mybookworktypefull}{ERROR: Defined degree (\mydegree) unknown, check \texttt{config/myconfig.tex}}
                                }                          
                              }                          
                            }                          
                          }                          
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}





\newcommand{\contactauthor}{\mybookauthor~\textless\href{mailto:\mybookemail}{\mybookemail}\textgreater}

\ifthenelse{\equal{\mybooklanguage}{english}}
{
  \newcommand{\keywordsforpdf}{\mybookkeywords}
}
{
  \newcommand{\keywordsforpdf}{\mybookpalabrasclave}
}

\hypersetup
{
  pdfauthor={\mybookauthor~\textless\href{mailto:\mybookemail}{\mybookemail}\textgreater},
  pdftitle={\mybooktitle},
  pdfsubject={\mydegreefull, \mybookworktypefull},
  pdfkeywords={\keywordsforpdf},
  pdfcreator={\LaTeX with hyperref package},
  pdfproducer={rubber},
  pdffitwindow={true},
  urlcolor=\myurlcolor,
  linkcolor=\mylinkcolor,
  citecolor=\mycitecolor
}




    
                               
\graphicspath{{./logos/}{./figures/}{./diagrams/}}                                                                 
\begin{document}

\frontmatter                                  

\makeatletter{}

\ifthenelse{\equal{\mybooklanguage}{english}}
{
  \selectlanguage{english}

  \floatname{codefloat}{Listing}
  \renewcommand{\lstlistingname}{Code}

                }
{
  \selectlanguage{spanish}
  
  \renewcommand{\tablename}{Tabla}
  \renewcommand{\listtablename}{Índice de tablas}

  \floatname{codefloat}{Listado}
  \renewcommand{\lstlistingname}{Codigo}


                }



  
                                              
\makeatletter{}

\ifthenelse{\equal{\mybookworktype}{TFG}}
{
  \makeatletter{}
\thispagestyle{empty}

\BgThispage


\begin{tikzpicture}[remember picture,overlay]
    \node[yshift=-5cm] at (current page.north west)
      {
        \begin{tikzpicture}[remember picture, overlay]
          \draw[fill=headingPortadaTFG,headingPortadaTFG] (0,0) rectangle (\paperwidth,5cm);
          \node [yshift=3cm, xshift=0.5\paperwidth, font=\Huge, text centered, midway] {\color{textoHeadingPortadaTFM}\textbf{\mybookuniversity}};
          \node [yshift=2cm, xshift=0.5\paperwidth, font=\Huge, text centered, midway] {\color{textoHeadingPortadaTFM}\textbf{\mybookschool}};

        \end{tikzpicture}
      };
   \end{tikzpicture}


\large
\vspace{5cm}
\begin{center}

    \LARGE\textbf{\mydegreefull}

  \vspace{25mm}

  \LARGE\textbf{\mybookworktypefull}

  \LARGE{\mybooktitle}

\vspace{5cm}

  \textbf{Autor:}  \mybookauthor 

\vspace{0.5cm}

  \textbf{\expandafter\makefirstuc\expandafter{\mybookTutorOrTutores}:}  \mybookadvisors

\end{center}

\begin{bottomparagraph}
  \begin{center}
    \huge{\mybookyear}
  \end{center}
\end{bottomparagraph}

\clearemptydoublepage


 
  \makeatletter{}
\thispagestyle{empty}
\large
\begin{center}

  \Huge\MakeUppercase{\mybookuniversity}


  \Large{\MakeUppercase{\mybookschool}}

  \vspace{7mm}

    \Large\textbf{\mydegreefull}

  \vspace{1cm}

  \Large\textbf{\mybookworktypefull}
        
  \vspace{1cm}   

  \Large\textbf{\mybooktitle}

  \vspace{1cm}
  
  Autor: \mybookauthor
  
  \vspace{1mm}
  

  \expandafter\makefirstuc\expandafter{\mybookDirectorOrDirectores}: \mybookadvisors
  
  \vspace{1cm}

  \begin{tabular}{rll}
    \textbf{Tribunal:} & &\\ 
    &&\\
    & \textbf{Presidente:} & \mybookpresident\\ \\ \\
    & \textbf{Vocal 1º:}   & \mybookfirstvocal\\ \\ \\
    & \textbf{Vocal 2º:}   & \mybooksecondvocal\\ \\
  \end{tabular}
\end{center}


\begin{bottomparagraph}
  \begin{flushleft}
  
  
    \begin{tabular}{p{1cm}c}
      &Calificación: ..................................................................................\\ \\
      &Fecha: ...........................................................................................
    \end{tabular}
  \end{flushleft}
\end{bottomparagraph}


\normalsize

\clearemptydoublepage



 
}
{
  \ifthenelse{\equal{\mybookworktype}{TFC}}
  {
    \makeatletter{}
\thispagestyle{empty}
\large
\vspace{3cm}
\begin{center}

  \Huge\textbf{\MakeUppercase{\mybookuniversity}}


  \textbf{\mybookschool}

  \vspace{1cm}

  \huge\textbf{\mydegreefull}
  
  \vspace{1cm}

  \centerline{\includegraphics[height=6cm]{uah/logoUAHazul.jpg}}

  \vspace{1cm}

  \Large\textbf{\mybookworktypefull}

  \vspace{0.5cm}   

  \LARGE\textbf{\mybooktitle}

  \vspace{2cm}

  \mybookauthor

\end{center}

\begin{bottomparagraph}
  \begin{center}
    \huge{\mybookyear}
  \end{center}
\end{bottomparagraph}

\clearemptydoublepage

 
    \makeatletter{}
\thispagestyle{empty}
\large
\begin{center}

  \Huge\MakeUppercase{\mybookuniversity}


  \Large{\MakeUppercase{\mybookschool}}

  \vspace{7mm}

    \Large\textbf{\mydegreefull}

  \vspace{1cm}

  \Large\textbf{\mybookworktypefull}
        
  \vspace{1cm}   

  \Large\textbf{\mybooktitle}

  \vspace{1cm}
  
  Autor: \mybookauthor
  
  \vspace{1mm}
  

  \expandafter\makefirstuc\expandafter{\mybookDirectorOrDirectores}: \mybookadvisors
  
  \vspace{1cm}

  \begin{tabular}{rll}
    \textbf{Tribunal:} & &\\ 
    &&\\
    & \textbf{Presidente:} & \mybookpresident\\ \\ \\
    & \textbf{Vocal 1º:}   & \mybookfirstvocal\\ \\ \\
    & \textbf{Vocal 2º:}   & \mybooksecondvocal\\ \\
  \end{tabular}
\end{center}


\begin{bottomparagraph}
  \begin{center}
    \begin{tabular}{p{3cm}c}
      &Calificación: ..........................................................................\\ \\
      &Fecha: ...................................................................................
    \end{tabular}
  \end{center}
\end{bottomparagraph}


\normalsize

\clearemptydoublepage



 
  }
  {
    \ifthenelse{\equal{\mybookworktype}{TFM}}
    {
      \makeatletter{}
\thispagestyle{empty}



\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-14cm] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \draw[fill=headingPortadaTFM,headingPortadaTFM] (0,0) rectangle (6cm,14cm);
      \node [yshift=7cm, xshift=3cm, text centered, midway, rotate=+90] {\color{white}\fontsize{110}{132}\selectfont\mybookuniversityacronym};
    \end{tikzpicture}
  };
\end{tikzpicture}

\begin{tikzpicture}
  \node [xshift=7cm] at (current page.north west)
  {     \begin{tikzpicture}[remember picture, overlay]
    
       \node [yshift=-3.5cm, xshift=0.5\paperwidth, align=center, text width=14cm, text centered, midway] {\begin{minipage}[c][13cm][c]{13cm}\centering\color{black}\fontsize{26}{31}\selectfont\textbf{\mybooktitle}\par\end{minipage}};
      
   
     \end{tikzpicture}
    
  };
\end{tikzpicture}

\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-\paperheight] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \draw[fill=headingPortadaTFM,headingPortadaTFM] (0,0) rectangle (\paperwidth,2cm);
    \end{tikzpicture}
  };
\end{tikzpicture}


\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-17cm] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \draw[fill=headingPortadaTFM,headingPortadaTFM] (0,0) rectangle (\paperwidth,2.8cm);
      \node [yshift=1.8cm, xshift=0.5\paperwidth, align=center, text width=0.95*\paperwidth, text centered, midway] {\color{white}\fontsize{20}{15}\selectfont\textbf{\mydegreefullwrapped}\par};
      \node [yshift=0.5cm, xshift=0.5\paperwidth, align=center, text width=0.95*\paperwidth, text centered, midway] {\color{white}\fontsize{20}{26}\selectfont\textbf{\mybookdepartment}};
    \end{tikzpicture}
  };
\end{tikzpicture}

\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-19cm] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \node [yshift=0,    xshift=0.5\paperwidth, text width=0.95\paperwidth, align=flush left] {\color{black}\fontsize{18}{15}\selectfont\textbf{Presentado por:\\\mybookauthor}\par};
      \node [yshift=-3cm, xshift=0.5\paperwidth, text width=0.95\paperwidth, align=flush left] {\color{black}\fontsize{18}{15}\selectfont\textbf{Dirigido por:\\\mybookadvisors}\par};
      \node [yshift=-6cm, xshift=0.5\paperwidth, text width=0.95\paperwidth, align=flush left] {\color{black}\fontsize{18}{15}\selectfont\textbf{Alcalá de Henares, a \mydefensedate}\par};

    \end{tikzpicture}
  };
\end{tikzpicture}

\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-\paperheight] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \draw[fill=headingPortadaTFM,headingPortadaTFM] (0,0) rectangle (\paperwidth,2cm);
    \end{tikzpicture}
  };
\end{tikzpicture}




\clearemptydoublepage


 
    }
    {
      \ifthenelse{\equal{\mybookworktype}{PHDUAH}}
      {
        \makeatletter{}
\thispagestyle{empty}
\large
\vspace{3cm}
\begin{center}

\color{pantone293}

  \centerline{\includegraphics[height=3cm]{uah/01_logo-vA_pant293.pdf}}

  \ifthenelse{\equal{\mybooklanguage}{english}}
  {
    \huge{{\mybookphdprogramEnglish}}
  }
  {
    \huge{{\mybookphdprogram}}
  }
  

  



  \vspace{2cm}   
  
  \Huge\textbf{\mybooktitle}

  \vspace{15mm}
  
  \ifthenelse{\equal{\mybooklanguage}{english}}
  {
    \huge{{PhD. Thesis Presented by}}
  }
  {
    \huge{{Tesis Doctoral presentada por}}
  }


  \huge{\textbf{\mybookauthor}}


  

\end{center}

\begin{bottomparagraph}
  \begin{center}
    \huge{\mybookyear}
  \end{center}
\end{bottomparagraph}

\color{black}

\clearemptydoublepage

 
        \makeatletter{}
\thispagestyle{empty}
\large
\begin{center}

  \color{pantone293}

  \centerline{\includegraphics[height=3cm]{uah/01_logo-vA_pant293.pdf}}

  \ifthenelse{\equal{\mybooklanguage}{english}}
  {
    \huge{{\mybookphdprogramEnglish}}
  }
  {
    \huge{{\mybookphdprogram}}
  }

  \vspace{2cm}   
  
  \Huge\textbf{\mybooktitle}

  \vspace{10mm}
  
  \ifthenelse{\equal{\mybooklanguage}{english}}
  {
    \huge{{PhD. Thesis Presented by}}
  }
  {
    \huge{{Tesis Doctoral presentada por}}
  }

  \huge{\textbf{\mybookauthor}}


  \vspace{10mm}

  \ifthenelse{\equal{\mybooklanguage}{english}}
  {
    \huge {\expandafter\makefirstuc\expandafter{\mybookAdvisorOrAdvisors}}
  }
  {
    \huge {\expandafter\makefirstuc\expandafter{\mybookDirectorOrDirectores}}
  }  

  \textbf{\mybookadvisors}

  
  \color{black}
  

\end{center}

\begin{bottomparagraph}
  \begin{center}

    \color{pantone293}

    \ifthenelse{\equal{\mybooklanguage}{english}}
    {
      \huge {Alcalá de Henares, \mydefensedateEnglish}
    }
    { 
      \huge {Alcalá de Henares, \mydefensedate}
    }  
    \color{black}

  \end{center}
\end{bottomparagraph}


\clearemptydoublepage






 
      }
      {
        \ifthenelse{\equal{\mybookworktype}{PHDUPM}}
        {
          \makeatletter{}
\thispagestyle{empty}
\large
\vspace{3cm}
\begin{center}

  \Huge\textbf{UNIVERSIDAD POLITÉCNICA DE MADRID}

  \vspace{1cm}

  \huge{Escuela Técnica Superior\\de Ingenieros de Telecomunicación} 

  \vspace{1cm}

\ifthenelse{\equal{\colorspaceused}{rgb}}
{
  \includegraphics[width=80mm]{logos/logoetsit_tamano.jpg}
}
{
  \includegraphics[width=80mm]{logos/logoetsit_tamano-cmyk.jpg}
}


  
  
  \LARGE\textbf{\mybooktitle}
  
  
  \mybookauthor

  \vspace{5mm}

  \mybookauthordegree

  \vspace{1cm}

\end{center}

\begin{bottomparagraph}
  \begin{center}
    \huge{\mybookyear}
  \end{center}
\end{bottomparagraph}


\clearemptydoublepage

 
          \makeatletter{}
\thispagestyle{empty}
\large
\begin{center}

  \Huge\textbf{UNIVERSIDAD POLITÉCNICA DE MADRID}

  \vspace{7mm}

  \huge{Escuela Técnica Superior\\de Ingenieros de Telecomunicación}

  \vspace{1cm}
  
  \centerline{\includegraphics[width=80mm]{logos/logoetsit_tamano.jpg}}


  \Large\textbf{\mybooktitle}

  
  \ifthenelse{\equal{\mybooklanguage}{english}}
  {
    \textbf {Author}
  }
  {
    \textbf {Autor}
  }
  
  
  \mybookauthor
  
  \vspace{1cm}
  
  \ifthenelse{\equal{\mybooklanguage}{english}}
  {
    \textbf {\expandafter\makefirstuc\expandafter{\mybookAdvisorOrAdvisors}}
  }
  {
    \textbf {\expandafter\makefirstuc\expandafter{\mybookDirectorOrDirectores}}
  }  
  
  \mybookadvisors
  
\end{center}

\begin{bottomparagraph}
  \begin{center}
    \textbf{\mybookyear}\\
    \vspace{5mm}
    \textbf{\mybookworktypefull}
  \end{center}
\end{bottomparagraph}


\normalsize

\clearemptydoublepage



 
        }
        {
          \ifthenelse{\equal{\mybookworktype}{GEINTRARR}}
          {
            \makeatletter{}
\thispagestyle{empty}



\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-14cm] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \draw[fill=headingPortadaTFM,headingPortadaTFM] (0,0) rectangle (6cm,14cm);
      \node [yshift=7cm, xshift=3cm, text centered, midway, rotate=+90] {\color{white}\fontsize{110}{132}\selectfont\mybookuniversityacronym};
    \end{tikzpicture}
  };
\end{tikzpicture}

\begin{tikzpicture}
  \node [xshift=7cm] at (current page.north west)
  {     \begin{tikzpicture}[remember picture, overlay]
    
       \node [yshift=-3.5cm, xshift=0.5\paperwidth, align=center, text width=14cm, text centered, midway] {\begin{minipage}[c][13cm][c]{13cm}\centering\color{black}\fontsize{26}{31}\selectfont\textbf{\mybooktitle{}\\}\par\fontsize{18}{26}\selectfont\textbf{[\mybookresearchreportID{}]}\par\end{minipage}};
      
   
     \end{tikzpicture}
    
  };
\end{tikzpicture}

\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-\paperheight] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \draw[fill=headingPortadaTFM,headingPortadaTFM] (0,0) rectangle (\paperwidth,2cm);
    \end{tikzpicture}
  };
\end{tikzpicture}


\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-17cm] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \draw[fill=headingPortadaTFM,headingPortadaTFM] (0,0) rectangle (\paperwidth,2.8cm);
      \node [yshift=1.8cm, xshift=0.5\paperwidth, align=center, text width=0.95*\paperwidth, text centered, midway] {\color{white}\fontsize{20}{15}\selectfont\textbf{\mybookworktypefull}\par};
      \node [yshift=0.5cm, xshift=0.5\paperwidth, align=center, text width=0.95*\paperwidth, text centered, midway] {\color{white}\fontsize{20}{26}\selectfont\textbf{\mybookdepartment}};
    \end{tikzpicture}
  };
\end{tikzpicture}

\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-19cm] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \node [yshift=0,    xshift=0.5\paperwidth, text width=0.95\paperwidth, align=flush left] {\color{black}\fontsize{18}{15}\selectfont\textbf{\mybookauthor}\par};
      \node [yshift=-6cm, xshift=0.5\paperwidth, text width=0.95\paperwidth, align=flush left] {\color{black}\fontsize{18}{15}\selectfont\textbf{Alcalá de Henares, \mydefensedate}\par};

    \end{tikzpicture}
  };
\end{tikzpicture}

\begin{tikzpicture}[remember picture,overlay]
  \node[yshift=-\paperheight] at (current page.north west)
  {
    \begin{tikzpicture}[remember picture, overlay]
      \draw[fill=headingPortadaTFM,headingPortadaTFM] (0,0) rectangle (\paperwidth,2cm);
    \end{tikzpicture}
  };
\end{tikzpicture}




\clearemptydoublepage


 
          }
          {
            ERROR: in \texttt{cover/cover.tex} Defined book type (\mybookworktype) unknown so that work type is
            undefined or wrong (\mybookworktype), check also \texttt{config/myconfig.tex}
          }
        }
      }
      
    }

  }

}


                        
                                                                                                                                                                                                                                                                                  
             
\makeatletter{}

\ifthenelse{\equal{\mybooklanguage}{english}}
{
  \chapter*{Acknowledgements}
  \label{cha:acknowledgements}
  \markboth{Acknowledgements}{Acknowledgements}
}
{
  \chapter*{Agradecimientos}
  \label{cha:agradecimientos}
  \markboth{Agradecimientos}{Agradecimientos}
}

\thispagestyle{myplain}

Este trabajo es el fruto de muchas horas de estudio y de trabajo que no habría sido posible sin la ayuda de mis compañeros Alejandro y Marcial y de mi director de proyecto Iván García.\\

Agradezco también a mi padre y a mi hermano su apoyo incondicional a lo largo de toda la carrera, que ha sido fundamental para superarla.





   
                                              
\makeatletter{}

\newacronym{HMI}{HMI}{Human-Machine Interfaces}
\newacronym{ETTS}{ETTS}{Emotional Text To Speech}
\newacronym{TTS}{TTS}{Text To Speech}
\newacronym{PSOLA}{PSOLA}{Pitch Synchronous OverLap Add}
\newacronym{TDPSOLA}{TD-PSOLA}{Time Domain Pitch Synchronous OverLap Add}
\newacronym{AI}{AI}{Artificial Intelligenge}

\newacronym{SPSS}{SPSS}{Statistical Parametric Speech Synthesis}
\newacronym{VC}{VC}{Voice Conversion}
\newacronym{US}{US}{Unit Selection}
\newacronym{HMM}{HMM}{Hidden Markov Model}
\newacronym{LSP}{LSP}{Line Spectral Pairs}
\newacronym{LPC}{LPC}{Linear Prediction Coefficiens}
\newacronym{LSF}{LSF}{Line Spectral Frequencies}
\newacronym{F0}{F0}{Fundamental Frequency}
\newacronym{MCEP}{MCEP}{Mel Cepstral Coefficients}
\newacronym{MGCEP}{MGCEP}{Mel Generalized Cepstral Coefficients}
\newacronym{MFCC}{MFCC}{Mel Frequency Cepstrum Coefficients}
\newacronym{ASR}{ASR}{Automatic Speech Recognition}
\newacronym{MDL}{MDL}{Minimum Description Length Criterion}
\newacronym{MSD}{MSD}{Multi Space Probability Distributions}
\newacronym{HSMM}{HSMM}{Hidden Semi-Markov Models}
\newacronym{ML}{ML}{Maximum Likelihood}
\newacronym{MLSA}{MLSA}{Mel Log Spectrum Approximation}
\newacronym{MAP}{MAP}{Maximum A Posteriori} 
\newacronym{MLLR}{MLLR}{Maximum Likelihood Linear Regression}
\newacronym{CSMAPLR}{CSMAPLR}{Constrain Structural MAP Linear Regression}
\newacronym{AV}{AV}{Average Voice}

\newacronym{ANN}{ANN}{Artificial Neural Network}

\newacronym{NIST}{NIST}{National Institute of Technology}
\newacronym{SES}{SES}{Spanish Expressive Speech}
\newacronym{EMODB}{EMODB}{Berlin Database of Emotional Speech}

\newacronym{FAUAIBO}{FAU-AIBO}{FAU AIBO Emotion Corpus}

\newacronym{SEV}{SEV}{Spanish Expressive Voices}
\newacronym{AER}{AER}{Automatic Emotion Recognition}
\newacronym{UBEC}{UBEC}{Universal Background Emotion Codebook}

\newacronym{STRAIGHT}{STRAIGHT}{Speech Transformation and Representation using Adaptive Interpolation of weiGHTed spectrum}


\newacronym{DBN}{DBN}{Dynamic Bayesian Network}
\newacronym{SQ}{SQ}{Speech Quality}
\newacronym{EIR}{EIR}{Emotion Identification Rate}
\newacronym{SIR}{SIR}{Speaker Identification Rate}
\newacronym{ES}{ES}{Emotional Strength}

\newacronym{ACCCHARS}{ÁÉÍÓÚÜÑáéíóúüñ}{Long ÁÉÍÓÚÜÑáéíóúüñ}





             
                                                                                            
\makeatletter{}

\newglossaryentry{ohm}{type=symbols,
        name={\ensuremath{\Omega}},
        symbol={\ensuremath{\Omega}}, 
        sort=ohm,
        description=unit of electrical resistance}

\newglossaryentry{angstrom}{type=symbols,
        name={\AA},
        symbol={\AA},
        sort=angstrom,
        description={non-SI unit of length}}

\newglossaryentry{xdet}{type=symbols,
        name={\ensuremath{x(t)}},
        symbol={\ensuremath{x(t)}},
        sort=xdet,
        description={Audio signal}}

\newglossaryentry{xidet}{type=symbols,
        name={\ensuremath{x_i(t)}},
        symbol={\ensuremath{x_i(t)}},
        sort=xidet,
        description={Audio signal captured at microphone $i$}}

\newglossaryentry{condindep}{type=symbols,
        name={\ensuremath{\ci}},
        symbol={\ensuremath{\ci}}, 
        sort=conditionalindependence,
        description=conditional independence}


               
                                                                                            




                  


\makeatletter{}
\hypersetup{linkcolor=\mytoclinkcolor}
\tableofcontents

\hypersetup{linkcolor=\myloflinkcolor}
\listoffigures
                          
\hypersetup{linkcolor=\mylotlinkcolor}
\listoftables

\hypersetup{linkcolor=\mylinkcolor}


\makeatletter{}
\hypersetup{linkcolor=\myothertoclinkcolor}
\ifthenelse{\equal{\mybooklanguage}{english}}
{
  \listof{codefloat}{List of source code listings}
  \addcontentsline{toc}{chapter}{List of source code listings}
}
{
  \listof{lstlisting}{Índice de listados de código fuente}    
  \addcontentsline{toc}{chapter}{Índice de listados de código fuente}
}











\makeatletter{}
\chapter*{Resumen}
\label{cha:resumen}
\markboth{Resumen}{Resumen}

\addcontentsline{toc}{chapter}{Resumen}

Este Trabajo de Fin de Grado ha consistido en estimar los ángulos de inclinación de una plataforma, sobre la que se han colocado dos motores, con el fin de estabilizarla en un ángulo de referencia indicado por el usuario. Para la estimación de los ángulos se ha utilizado un conjunto de sensores llamados giróscopos y acelerómetros, ambos de tres ejes, que están integrados en un sensor llamado IMU. Los motores se han controlado mediante un ESC (Electronic Speed Controller), que además cumple la función de inversor. 
\\

\textbf{Palabras clave:} \mybookpalabrasclave.



                   
\makeatletter{}
\chapter*{Abstract}
\label{cha:abstract}

\addcontentsline{toc}{chapter}{Abstract}

This Final Year Project's purpose is to estimate the tilt angle of a platform, which has two engines installed above, in order of stabilize it in the angle that the user desires. To estimate the angles a set of sensors called gyroscopes and accelerometers have been used, both of three axis, integrated into a sensor called IMU. The engines have been controlled using a electronic speed controller (ESC), that also serves as a DC/AC converter.
\\


\textbf{Keywords:} \mybookkeywords.
                
                                              
\makeatletter{}


\chapter*{Resumen Extendido}
\label{cha:resumen-extendido}

\addcontentsline{toc}{chapter}{Resumen Extendido}

Este proyecto consiste en controlar los dos motores que se encuentran en un eje de un cuadridóptero para que se ajuste a un ángulo de referencia pasado como entrada al sistema. El proyecto consta de varias etapas que se explicarán brevemente en este resumen.\\


La primera etapa de este proyecto será estudiar los componentes disponibles de los distintos fabricantes y decidir cuáles son los más adecuados para el proyecto en función de su precisión, de su facilidad de uso y del precio. Los componentes necesarios para llevar a cabo este proyecto son:

\begin{itemize}

	\item {\bf Sensor de posición}
	\item {\bf Microcontrolador}
	\item {\bf Controladores de los Motores (ESC)}
	\item {\bf Motores}
	\item {\bf Batería o fuente de alimentación}
		
\end{itemize}
 
 Una vez elegidos los componentes que se van a utilizar se debe realizar un estudio del principio de medida de los sensores utilizados. Los sensores que se van a utilizar para estimar el ángulo de la plataforma, ambos integrados en una IMU (Inertial Measurement Unit), son:

\begin{itemize}

	\item {\bf Giróscopo}
	\item {\bf Acelerómetro}
		
\end{itemize}

El principio de medida de estos dos sensores no es el mismo y en ninguno de los dos casos proporcionan una medida directa del ángulo, pero con unas sencillas operaciones se puede obtener de ambos sensores una medida de la posición. Ambos sensores presentan errores que son intolerables para esta aplicación, sin embargo utilizando los dos en conjunto se obtiene una medida de alta precisión del ángulo. Se especificará en la memoria cómo se obtiene el ángulo a partir de sus medidas.
\\

El controlador que se va utilizar para el proyecto será un Arduino Uno, elegido por su bajo coste y la facilidad en la programación. La plataforma Arduino tiene una gran cantidad de librerías disponibles que hacen que sea muy fácil interactuar con sensores y con actuadores conectados al Arduino. La comunicación entre la IMU y el Arduino se realiza mediante el protocolo de comunicación serie $I^2C$, mediante el cual se pueden conectar distintos componentes al Arduino y controlarlos mediante el puerto serie. Por tanto el primer paso para la adquisición de datos será realizar un programa para la recepción de datos mediante el puerto serie desde la IMU. Teniendo el programa de recepción de datos hecho sólo queda realizar un programa para procesar esas medidas y obtener una medida del ángulo dar finalizada esta etapa..
\\
\\
La siguiente etapa del proyecto consistirá en realizar un estudio del ESC (Electronic Speed Controller) y de los motores. Se debe determinar el funcionamiento de ambos componentes para poder realizar un controlador adecuado. Para el estudio se utilizarán las especificaciones del fabricante además de realizar pruebas experimentales con el fin de comprobar su funcionamiento real.\\
\\
La etapa final del proyecto es la estabilización del brazo. Llegado a este punto ya se ha implementado el programa para medir el ángulo del brazo con una precisión adecuada y ya se ha estudiado la forma de variar la velocidad de los motores, por lo tanto se realizará el control del brazo mediante distintos reguladores.

%mainmatter y deactivatetilden desactivan los numeros romanos del indice y reinician la cuenta

\mainmatter                                       \deactivatetilden     

\makeatletter{}



\part{Introducción}

\chapter{Introducción}
\label{cha:introduccion}


\section{Presentación}
\label{sec:presentacion}

Para conocer el primer concepto de cuadricóptero construido hay que remontarse al año 1922. Ese año el norteamericano George de Bothezat fue el primero en hacer volar un aparato con cuatro rotores pero sin mucho éxito, pues el aparato no consiguió subir más de 5 metros. 

		\begin{figure}[!h]
			\centering
			\includegraphics[scale=0.4]{images/americano}\label{fig: americano} 
			
			\caption{Cuadricóptero de Bothezat}
			
		
		\end{figure}
		
Un europeo, el francés  Étienne Oehmichen realizó experimentos durante los años 1923 y 1924 en los que consiguió un vuelo estacionario de cinco minutos de duración y un vuelo estacionario de siete minutos de duración elevando el aparato 10 metros sobre el suelo. 

\begin{figure}[!h]
			\centering
			\includegraphics[scale=0.4]{images/frances}\label{fig: frances} 
			
			\caption{Cuadricóptero de Oehmichen}
			
		
		\end{figure}
		
		El trabajo de estos dos ingenieros se puede considerar el comienzo de los aparatos aéreos con cuatro rotores. 
		\\
		  

Debido a la complejidad en el control de estos aparatos las investigaciones se centraron más en los helicópteros de una hélice que conocemos hoy en día. Sin embargo, a lo largo de la última década el uso de aparatos aéreos de reducidas dimensiones, como cuadricópteros y drones, se ha incrementado exponencialmente. En la actualidad es muy común su uso en diversos ámbitos, siendo los más destacables su uso militar, uso comercial y uso como método de grabación en la industria cinematográfica. En todos los casos el aparato más usado es un vehículo aéreo no tripulado (UAV) basado en un sistema de aterrizaje y despegue vertical (VTOL), categoría que engloba a los cuadricópteros. Las ventajas comunes a todos los ámbitos son su facilidad de uso, facilidad de transporte y su reducido coste. Los usos que se le dan en cada campo  son:

						\begin{itemize}

	\item {\bf Militar}: se utiliza como observador de la zona en la que van a operar los soldados sin poner en riesgo vidas humanas.
	\item {\bf Comercial}: varias empresas, entre las que se incluye Amazon, están investigando su uso como medio para repartir paquetes en áreas urbanas. 
	
	\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.35]{images/Amazon}
			\label{fig: Drone Amazon}
			\\
			\caption{Cuadricóptero de Amazon en pruebas}
		
\end{figure}
	
	\item {\bf Industria cinematográfica}: su uso permite reducir los costes de producción en tomas aéreas. Las tomas que hasta ahora se tenían que realizar mediante un helicóptero se pueden realizar con los cuadricópteros a un coste mucho menor.
	
	\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.25]{images/djiphantom}
			\label{fig: Cine }
			\\
			\caption{Cuadricóptero con cámara acoplada}
		
\end{figure}
		
\end{itemize}

Estas son las aplicaciones más conocidas de estos aparatos. No obstante, tienen otras muchas aplicaciones como revisión del estado de las líneas de alta y media tensión por parte de las compañías eléctricas, revisión del estado de los aerogeneradores mediante un modelo llamado Aracnocopter, análisis del ambiente en zonas de alto riesgo para los humanos como zonas volcánicas...



\section{Estado del arte}
\label{sec:arte}

En este apartado se van a enumerar algunos trabajos de otros grupos de investigación el el campo de los cuadricópteros que sean innovadores respecto a la mayoría de las investigaciones.

\begin{itemize}

	\item En  \cite{primertrabajo} se realiza el diseño y el control de un cuadricópetro con vuelo autónomo y con variador del ángulo de inclinación de las hélices. Los aspectos más destacables de este proyecto son los servos añadidos a las hélices para variar el ángulo de éstas; además ha implementado un software que permite el vuelo invertido del aparato.
	
	\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.5]{images/vueloinvertido}
			\label{fig:vueloinvertido }
			\\
			\caption{Detalle del vuelo invertido del cuadricóptero}
		
\end{figure}
	
	
	
	\item En  \cite{segundotrabajo} se utiliza una tecnología denominada BCI\footnote{Siglas de Brain-computer interface (Interfaz cerebro-computadora)}, que es una tecnología que consiste en la adquisición de ondas cerebrales para luego ser procesadas e interpretadas por un ordenador. En él se realiza un experimento en el que se controla un cuadricópetro en un espacio tridimensional usando un electroencefalograma no invasivo.
	
	\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.4]{images/bci}
			\label{fig:vueloinvertido }
			\\
			\caption{Diagrama conceptual de la potencial función de la robótica de telepresencia BCI impulsada en la restauración de la autonomía a una persona paralizada.}
		
\end{figure}
		
\end{itemize}

\section{Motivación y objetivos del proyecto}
\label{sec:motivación}


\subsection{Motivación}


Debido a la mayor presencia de estos aparatos año tras año en múltiples aplicaciones este proyecto se va a centrar en estudiar el método de medida de la posición de un eje de un cuadricóptero y su posterior estabilización mediante distintos reguladores. Ya que la distribución de los motores en el cuadricóptero es simétrica, el algoritmo de control de estabilización del brazo con el que se va a trabajar se puede aplicar al otro brazo para estabilizar el vuelo del cuadricóptero; por lo tanto este proyecto no se va a centrar en aspectos mecánicos ni en la aerodinámica del aparato sino en la teoría de control y en la programación del controlador para procesar los datos de los sensores y usarlos para el algoritmo de estabilización.\\
\\
Mediante la realización de este proyecto se afianzan conocimientos estudiados durante la carrera en los campos de:

	
\begin{itemize}

	\item {\bf Control}: se deben utilizar los conocimientos adquiridos en las distintas asignaturas de control para el control del brazo.

	\item {\bf Circuitos eléctricos}: se deben conectar dos circuitos muy simples, uno de control que enviará las señales de comunicación entre sensor y Arduino y entre ESC y Arduino, y otro circuito de potencia que alimentará los motores desde la fuente de alimentación que se utilice.
	
	\item {\bf Programación}: se requieren conocimientos estudiados en asignaturas de programación y en sistemas digitales (para el manejo de registros de un microcontrolador) para programar el microcontrolador, que generalmente requieren el lenguaje C o C++. 
	
	\item {\bf Instrumentación Electrónica}: se utilizará el programa LabView aprendido en esta asignatura para realizar una interfaz gráfica que se comunique con el microcontrolador y permita controlar el brazo con más facilidad.
	
	
		
\end{itemize}

\subsection{Objetivos}

El proyecto se dará por concluido cuando se cumplan los siguientes objetivos:

		\begin{enumerate}

	\item  Análisis y estimación de de los 3 grados de libertad del cuadricóptero obtenidos de la IMU.	
	
	\item Diseño del PID y de otros reguladores para el control del ángulo del brazo.
	
	\item Programación de la interfaz gráfica en LabView para manejar el brazo.
	
		
\end{enumerate}
	
\section{Medios y herramientas necesarios}
\label{sec:Medios}

En este apartado sólo se enumerarán los recursos necesarios para la realización del proyecto, más adelante, en otro apartado, se explicarán más en detalle las características de cada uno de los componentes y programas aquí enumerados. Para realizar este proyecto es necesario disponer de:

	
\begin{multicols}{2}

\begin{itemize}



	\item Microcontrolador
	
	\item  IMU
	
	\item  LabView
	
	\item  PC
	
	\item Batería o fuente de alimentación
	
	\item Motores Brushless
	
	\item Hélices
	
	\item Controladores de velocidad (ESC)
	
	\item Estructura de ensamblaje
	
	\item Matlab
	
	\item AutoDesk Inventor
	
		
	
\end{itemize}

\end{multicols}



\part{Elección de los componentes}

\chapter{Elección de los componentes}


En este apartado del trabajo se van a a estudiar los distintos componentes presentes en el mercado y se van a elegir los más adecuados. De cada componente se comentarán sus especificaciones y sus características detalladamente.

\section{Controlador}
\label{sec:controlador}
Este componente es el cerebro del cuadricóptero, es el encargado de recoger todos los datos de los sensores para procesarlos y generar las señales necesarias que se enviarán a los motores para estabilizar el brazo. Para esta aplicación no se requiere un procesador con mucha capacidad de cómputo, los requisitos necesarios para que el controlador sea válido son:

\begin{enumerate}



	\item {\bf Puerto serie}: es necesario para la comunicación con el sensor y con el ordenador. Mediante la lectura del puerto serie se leerán los datos de los sensores y mediante la escritura en el puerto serie se enviarán órdenes desde el programa realizado en el ordenador al controlador.
	
	\item  {\bf Entradas/Salidas digitales con PWM}: la excitación de los motores se realiza mediante una señal PWM, la cual se envía a través de estos puertos.
	
\end{enumerate}

Con estas características se puede buscar en Internet la oferta de controladores disponible que cumplan las características especificadas. Los dos controladores más completos y con mejor relación calidad/precio son el Arduino Uno y el A-Star 32U4 Prime SV, cuyas características se enumerarán a continuación.

\subsection{Arduino Uno}
\label{subsec:arduino}

Esta placa está basada en un microcontrolador ATmega328 y dispone de 14 entradas/salidas digitales, de las cuales 6 pueden ser usadas como salidas PWM. Se conecta al ordenador mediante USB, que sustituye al antiguo puerto serie RS232 y dispone de puertos para la comunicación serie. Por lo tanto este microcontrolador cumple con los requisitos necesarios para poder realizar este trabajo.


\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.9]{images/arduinouno}
			\label{fig:arduino }
			\\
			\caption{Microcontrolador Arduino Uno}
		
\end{figure}
	

Una de las ventajas de usar la plataforma Arduino es la enorme cantidad de documentación disponible en Internet para cualquier proyecto relacionado con Arduino. Ya que es una plataforma de código abierto hay una comunidad de desarrolladores que ha generado toda esa información y resulta muy sencillo aprender a programar el micro. 

\subsection{A-Star 32U4 Prime SV}
\label{subsec:astar}

Esta placa está basada en un microcontrolador ATmega32U4 y dispone de 14 entradas/salidas digitales, de las cuales 7 pueden ser usadas como salidas PWM. Se conecta al ordenador mediante micro-USB, que sustituye al antiguo puerto serie RS232 y dispone de puertos para la comunicación serie. Por lo tanto este microcontrolador cumple con los requisitos necesarios para poder realizar este trabajo.


\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.5]{images/astar}
			\label{fig:arduino }
			\\
			\caption{Microcontrolador A-Star 32U4 Prime SV}
		
\end{figure}
	

La ventaja de este microcontrolador respecto al Arduino es un mayor rango de voltaje de alimentación y mayor número de entrads/salidas disponibles para el usuario.

\newpage

\subsection{Comparativa y elección}
\label{subsec:comparativamicros}


\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Comparativa controladores programables.}
  \label{table1}
  \begin{center}
            \begin{tabular}{|c|c|c|}
      \hline
      \rowcolor{LightBlue2}   & {\bf Arduino Uno} &  {\bf A-Star 32U4 Prime SV} \\
      \hline
      Microcontrolador & ATmega328P & ATmega32U4\\
      \hline
      Entradas/Salidas & 20 & 26\\
      \hline
       Salidas PWM & 6 & 7\\
      \hline
      Rango de tensión de entrada & 7 a 12 V & 5 a 36 V\\
      \hline
      Precio & 20 \euro & 28 \euro\\
      \hline
    \end{tabular}
  \end{center}
\end{table}

Las mayores diferencias entre ambos controladores están en el número de entradas y en el margen de tensiones de entrada. En este trabajo sólo se van a  necesitar 2 salidas PWM, por lo tanto cualquiera de los controladores son válidos. Las tensiones de entrada tampoco son relevantes a la hora de elegir una opción u otra ya que la oferta de baterías y fuentes de alimentación es muy amplia. La mayor disponibilidad de documentación disponible en la plataforma Arduino hace que el aprendizaje y el desarrollo sean más rápidos, por lo tanto es la mejor opción. El controlador usado será el {\bf Arduino Uno}.


\section{Unidad inercial de medidas (IMU)}
\label{sec:seleccionimu}

La unidad inercial de medidas o IMU por sus siglas en inglés es un dispositivo que combina un conjunto de sensores capaces de medir la aceleración, la velocidad angular y el campo magnético. Los sensores capaces de medir esas 3 magnitudes son el acelerómetro, el giróscopo y el magnetómetro. En general, las IMUs disponibles en el mercado son capaces de medir estas magnitudes en las 3 direcciones del espacio pues integran 3 acelerómetros, 3 giróscopos y 3 magnetómetros. En capítulos posteriores se explicará detalladamente el funcionamiento del giróscopo y del acelerómetro, pues el magnetómetro no es usado en este trabajo. Esta apartado se centra  en comparar los modelos más apropiados para este trabajo. Las dos IMU que se van a comparar son la Alt-IMU-10 de Pololu y la MPU-6050 de Invensense.

\subsection{AltIMU-10}
\label{subsec:altimu}

Esta IMU \cite{pololu} combina un barómetro digital, un giróscopo de 3 ejes, un acelerómetro de 3 ejes, un magnetómetro de 3 ejes y un altímetro. Por lo tanto es un dispositivo con 10 grados de libertad. La ventaja de elegir esta IMU es que el vendedor proporciona unas librerías mediante las que leer los valores de los sensores sin tener que recurrir a lecturas de registros; sólo hay que hacer llamadas a las funciones definidas en la librería y se leerán los datos de los sensores. 


\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.2]{images/altimu1}
			\label{fig:altimu}
			\\
			\caption{AltIMU-10}
		
\end{figure}
	
Esta IMU es compatible con el controlador elegido pues rango de tensiones de alimentación es 2.5 V a 5.5 V y la corriente necesaria 6 mA (cada pin del Arduino entrega hasta 40 mA de corriente). Además incluye un regulador de tensión de 3.3 V, cuando al pin de alimentación VIN se le alimenta a  3.3 V o más, el pin VDD actúa como una fuente de 3.3 V que puede suministrar hasta 150 mA a componentes externos. Los rangos de FS\footnote{FS hace referencia a fondo de escala} se especificarán más adelante en la tabla comparativa.\\
\\
La lectura se realiza mediante comunicación I$^2$C, que es un protocolo de comunicación serie. Tiene un conversor digital-analógico por canal, es decir uno para cada eje de cada sensor, característica que asegura medidas de mucha precisión.

\subsection{MPU 6050}
\label{subsec:mpu}

Este dispositivo \cite{mpu} combina un giróscopo de 3 ejes y un acelerómetro de 3 ejes. Es un dispositivo con 6 grados de libertad. En este caso el fabricante no proporciona librerías y las operaciones para leer datos de los sensores son algo más complejas, necesitando acceder a registros y realizar operaciones de desplazamiento de bits para obtener los datos de los sensores.

\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.4]{images/mpu1}
			\label{fig:mpu}
			\\
			\caption{MPU 6050}
		
\end{figure}
	
También es compatible con Arduino pues su rengo de tensión de alimentación es 2.375 V a 3.46 V. La lectura se realiza mediante comunicación I$^2$C. Tiene un conversor digital-analógico por canal, es decir uno para cada eje de cada sensor, característica que asegura medidas de mucha precisión. 


\subsection{Comparativa y elección}
\label{subsec:comparativaimu}


\begin{table}[H]
    \renewcommand{\arraystretch}{1.3}
  \caption{Comparativa IMU.}
  \label{table2}
  \begin{center}
            \begin{tabular}{|c|c|c|}
      \hline
     \rowcolor{LightBlue2}  &   {\bf AltIMU-10} & {\bf MPU 6050} 				\\
      \hline
     
     Rangos FS giróscopos & $\pm 245, {\pm 500} ,{\pm 2000} º/s  &  \pm 250, \pm 500, \pm 1000 , \pm 2000 º/s$\\
      \hline
      Rangos FS acelerómetros & $\pm 2, \pm 4, \pm 6 , \pm 8,\pm 16 g& \pm 2, \pm 4, \pm 6 , \pm 8,\pm 16 g$\\
      \hline
      Rango de tensión de entrada & 2.5 a 5.5 V & 2.375 a 3.46 V\\
      \hline
      Precio & 30 \euro & 6 \euro\\
      \hline
    \end{tabular}
  \end{center}
\end{table}

La única diferencia significativa es el precio. No obstante la mayor facilidad a la hora de programar para leer los valores de los sensores va a reducir el error significativamente y merece la pena esa diferencia de costes. La IMU que se usará en este trabajo es la {\bf AltIMU-10}.





\section{Motores}
\label{sec:eleccionmotores}

La elección de unos motores adecuados resulta imprescindible, pues de sus características dependerá la estabilización y el consumo de energía. Los dos tipos de motores entre los que hay que elegir son los motores con escobillas, que generalmente son motores de continua, o motores sin escobillas. Para analizar las diferencias entre los motores se ha utilizado información obtenida de \cite{Vila}.

\subsection{Motores DC (Brushed Motors)}
\label{subsec:motordc}

Estos motores están compuestos de dos partes, un estator que sirve como soporte mecánico y en el que se encuentran los polos, y un rotor que recibe la corriente de las escobillas. La función de las escobillas es la de cambiar la dirección de la corriente que circula por sus bobinas, esta conmutación produce un par de rotación en el eje. Estos motores no necesitan ningún tipo de controlador para variar su velocidad debido a la conmutación mecánica mediante escobillas, por lo que el control es simple.


\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.35]{images/motorcontinua}
			\label{fig:motorcontinua}
			\\
			\caption{Motor de corriente continua}
		
\end{figure}

El principal inconveniente de este tipo de motores es que debido al rozamiento del rotor con las escobillas se produce un desgaste debido al que hay sustituir las escobillas con mucha frecuencia. En consecuencia el coste de mantenimiento es elevado.



\subsection{Motores sin escobillas (Brushless Motors)}
\label{subsec:motorsinescobillas}

Son similares a los motores de corriente continua en su estructura pues usan bobinas e imanes para mover el eje pero su funcionamiento es muy distinto. Con motores de alterna trifásicos y debido a que no hay ningún elemento mecánico como las escobillas que inviertan el sentido de la corriente es necesario para regular la velocidad de giro un controlador electrónico de velocidad (ESC). El ESC además funciona como inversor, convirtiendo la corriente continua suministrada por las baterías a corriente alterna necesaria para alimentar el motor.


\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.3]{images/motorbrushless}
			\label{fig:motorbrushless}
			\\
			\caption{Motor sin escobillas}
		
\end{figure}

De este tipo de motores existen dos posibles configuraciones, de rotor externo o de rotor interno. Su nombre indica la posición de las bobinas del respecto a los imanes permanentes. 


\subsection{Comparativa y elección}
\label{subsec:comparativamotores}



\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Comparativa Motores.}
  \label{table3}
  \begin{center}
            \begin{tabular}{|c|c|c|}
      \hline
      \rowcolor{LightBlue2}   & {\bf Motor sin escobillas} &  {\bf Motor continua} \\
      \hline
      Mantenimiento & Bajo & Elevado\\
      \hline
      Eficiencia & Alta & Media\\
      \hline
      Conmutación & Electrónica & Mecánica\\
      \hline
      Ruido electrónico & Bajo & Alto \\
      \hline
      Precio & 15 \euro & 7 \euro\\
      \hline
    \end{tabular}
  \end{center}
\end{table}

Las ventajas de elegir un motor sin escobillas se observan en la tabla 1.3. Sin embargo esas no son todas las ventajas, al no haber escobillas no hay rozamiento y el rango de velocidad es más elevado al no tener limitación mecánica, también tienen mayor eficiencia pues la pérdida de calor es mucho menor y, como última consecuencia de no tener escobillas, el rendimiento es mayor, con la misma potencia eléctrica suministrada el motor sin escobillas adquiere mayor velocidad. Por todas estas ventajas, a pesar de la diferencia de coste, se va a utilizar el {\bf Motor Brushless}. Por lo tanto el siguiente paso será elegir un controlador electrónico de velocidad.\\
\\
Para estos tipos de motores el fabricante suele especificar, además de los parámetros comunes a los motores de continua, el factor Kv, que indica el número de revoluciones por minuto por cada voltio de tensión que se le aplica al motor. Ya que el peso que tienen que levantar los motores no es muy elevado, no se requiere de un gran factor Kv ni de un gran par en los motores para este trabajo. En la tabla \ref{table4} se indican las especificaciones del motor elegido.

\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Especificaciones motor.}
  \label{table4}
  \begin{center}
            \begin{tabular}{|c|c|}
      \hline
      \rowcolor{LightBlue2}   & {\bf Motor sin escobillas A2212} \\
      \hline
      Eficiencia Máxima & 80 \%\\
      \hline
      Kv & 1000 \\
      \hline
      Diámetro del eje & 3.17mm \\
      \hline
      Tensión alimentación & 7.4 a 14.8 V  \\
      \hline
      Corriente sin carga & 0.5 A \\
      \hline
      
       Corriente Máxima & 12 A \\
      \hline
    \end{tabular}
  \end{center}
\end{table}




\section{Controlador electrónico de velocidad}
\label{sec:ESC}

Los motores brushless, como se ha mencionado en la sección \ref{sec:eleccionmotores}, necesitan para regular su velocidad de giro mediante la conmutación de la sentido de la corriente un dispositivo llamado controlador electrónico de velocidad. Es un circuito electrónico utilizado para variar la dirección del motor, la velocidad e incluso para actuar como freno. 


\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.3]{images/ESC}
			\caption{ESC.}
			\label{fig:ESC}
		
\end{figure}

Los distintos cables que se ven en la figura \ref{fig:ESC} corresponden a:


\begin{itemize}


		\item {\bf 3 cables izquierda (Amarillo, rojo y negro)}: cables de conexión al motor, cada uno corresponde a una fase.
		
		\item {\bf 2 cables derecha (Rojo y negro)}: estos cables deben conectarse a la batería, son los cables de alimentación.
		
		\item {\bf Conector de 3 cables derecho}: estos 3 cables son los cables de señal, el rojo y negro corresponden a Vcc y a masa y el blanco es el cable de señal.



\end{itemize}

Los controladores están regulados por una señal PPM (modulación por posición de pulso), que son similares a las señales PWM.  En este tipo de señales la tensión aplicada en bornes del motor será el valor medio del tren que estará acotado entre 1 y 2 ms, es decir, con 1 ms el motor gira a la velocidad mínima y con 2 ms el motor gira a la velocidad máxima. La frecuencia a la que se trabaja en este proyecto es de 33.33 Hz.\\
\\
Un ejemplo de una señal de excitación para un ESC se muestra en la figura \ref{fig:senalesc1}.

\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.5]{images/senalesc}
			\caption{Señal ESC.}
			\label{fig:senalesc1}
\end{figure}

En esta señal se puede observar el rango de velocidades y el funcionamiento del motor en cada caso. Si se excita el motor a una velocidad menor de la mínima no arrancará y si se excita a una velocidad mayor de la máxima existe el riesgo de romper el motor. La forma de mandar estas señales al ESC se explicará en detalle en el capítulo \ref{part:motoresyesc}.


Las características de las distintas opciones disponibles en el mercado son muy similares, por lo tanto se ha elegido un ESC que tiene una buena relación calidad/precio. Sus especificaciones se muestran en la tabla \ref{table5}. 

\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Especificaciones ESC.}
  \label{table5}
  \begin{center}
            \begin{tabular}{|c|c|}
      \hline
      \rowcolor{LightBlue2}   & {\bf ESC} \\
      \hline
      Salida & 30 A continuo, 40A hasta 10 secs \\
      \hline
      Voltaje de entrada & 2-4 baterías LiPo \\
      \hline
    
    \end{tabular}
  \end{center}
\end{table}

\section{Hélices}
\label{sec:helices}

\parbox{0.3\textwidth}{ \includegraphics[scale=0.04]{images/helices}} \parbox{0.7\textwidth}{ Como el brazo sólo va a realizar un movimiento de rotación en un solo eje no se necesitan unas hélices muy grandes pues no es necesaria mucha fuerza de empuje. Por ello se han elegido unas hélices de unas dimensiones estándar que darán la fuerza de empuje necesaria para mover el brazo. Las dimensiones de las hélices son 200 mm de un extremo a otro y 6 mm el diámetro del eje. } 

\newpage

\section{Batería o fuente de alimentación}
\label{sec:ESC}

Las corrientes que necesitan los motores son bastante elevadas debido a la oposición de las bobinas a cambios en la corriente que circulan a través de ellas. Las baterías que se suelen utilizar en los cuadricópteros se denominan baterías LiPo, que son baterías de polímero de Litio. Cada una de estas baterías está compuesta por celdas en paralelo, cada celda suele tener un voltaje de 3.7 V y las ventajas que tienen es que son muy ligeras (conveniente para el cuadricóptero) y proporcionan grandes descargas de corriente. 

\begin{figure}[H]
		\centering
			\includegraphics[scale=0.1]{images/LiPo}
			\label{fig:LiPo}
			\\
			\caption{Batería LiPo}
		
\end{figure}

Uno de los problemas de estas baterías es que si se descargan demasiado, es decir, la tensión es inferior a un valor facilitado por el fabricante, la batería deja de funcionar. Además si se les suministra demasiada corriente en la recarga pueden llegar a explotar. Ya que este trabajo está centrado en estabilizar un brazo que va a tener una base de apoyo se va a utilizar una fuente de alimentación, que son más seguras y la tensión proporcionada es más estable.

\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.4]{images/fuente}
			\label{fig:fuente}
			\\
			\caption{Fuente de alimentación utilizada}
		
\end{figure}

La fuente utilizada tiene dos fuentes independientes, una de 5 V y una de 12 V. En este trabajo se utilizará la fuente de 12 V. Las características de la fuente de alimentaciónse muestran en la tabla \ref{table6}.

\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Especificaciones fuente de alimentación.}
  \label{table6}
  \begin{center}
            \begin{tabular}{|c|c|c|}
      \hline
      \rowcolor{LightBlue2}   & {\bf 5 V} & {\bf 12 V}\\
      \hline
      Salida & 13 A (Pico)& 6 A (Pico) \\
      \hline
      Entrada & 180-240 V & 180-240 V \\
      \hline
    
    \end{tabular}
  \end{center}
\end{table}


\section{Montaje final}

Para montar el brazo se necesita un material que sea ligero y que sea fácil de trabajar, para que el montaje de la estructura no resulte costosa. El material usado en este trabajo es el aglomerado, que se obtiene a partir de virutas o serrín. Su manipulación sólo requiere de una sierra de vaivén y se puede taladrar fácilmente para acoplar las distintas partes. El montaje del brazo debe tener suficiente peso y suficiente superficie en la base para que ante movimientos bruscos en la fase de pruebas del PID la estructura no se balancee, sólo debe moverse el brazo a estabilizar. \\

\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.078]{images/estructuraensamblada}
			\caption{Brazo montado.}
			\label{fig:estructuraensamblada}
\end{figure}

La estructura de la figura \ref{fig:estructuraensamblada} tiene un eje central sobre el que puede girar libremente el brazo. Para que las hélices no pasen de un ángulo de aproximadamente 75º por cada lado, caso en el que chocarían contra las barras de soporte del brazo y sería peligroso, se ha colocado un tope de madera entre las barras para limitar el movimiento; además se limitará también por software para mayor seguridad. Para que el centro de gravedad del montaje descienda se ha colocado una pesa en la base y se disminuye el riesgo de volcar ante acelerones bruscos de los motores.


\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/circuitofritzing}
    \caption{Esquema del circuito.}
  \end{subfigure}  
      \begin{subfigure}{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/circuito}
    \caption{Foto del circuito real.}
  \end{subfigure}
  \caption{Imágenes del esquema y del circuito montado.}
  \label{fig:esquemaycircuito}
\end{figure}

En la figura \ref{fig:esquemaycircuito} se muestran el esquema del circuito montado y una imagen real del circuito. En el esquema sólo se ha representado uno de los motores porque la conexión del otro es idéntica. 

\begin{sidewaysfigure}[!h]
		\centering
			\includegraphics[width=\textwidth]{images/BrazoTFG}
			\caption{Alzado, planta y perfil de la estructura.}
			\label{fig:vistasdiedrico}
\end{sidewaysfigure}


\part{Sensores de posición}
\label{part:sensoresdeposicion}

\chapter{Sensores de posición}
\label{chapter:sensores}

\section{Introducción}
\label{sec:introduccionsensores}

Como ya se ha comentado previamente, en este trabajo se van a utilizar dos sensores para estimar el ángulo del brazo, el giróscopo y el acelerómetro. Ninguno de los dos sensores da una medida directa del ángulo, por lo tanto hay que realizar algunas cálculos para estimar el ángulo. En este capítulo se explicarán todos los pasos necesarios para llegar a obtener medidas precisas del ángulo del brazo, desde la conexión de los componentes hasta la realización de los programas. \\



Ambos sensores están integrados integrados en un chip denominado IMU. La IMU utilizada es la AltIMU-10 de Pololu e integra en el mismo chip un giróscopo de 3 ejes, un acelerómetro de 3 ejes, un magnetómetro de 3 ejes y un altímetro dando un total de 10 medidas independientes, lo que forma un sensor de 10 DOF\footnote{Grados de libertad}.

\section{Conexión de la IMU}
\label{sec:conexionimu}

Para poder tomar medidas de la IMU hay que conectar 4 pines, los de alimentación y los de la comunicación serie. Los pines de la IMU se muestran en la figura \ref{fig:pinesimu}. Los pines de alimentación son el pin Vin para el positivo y GND para masa. Se puede conectar a un rango de tensiones de entre 2.6 y 5.5 V. La corriente de suministro que necesita es 6 mA, cada pin de Arduino suministra 40 mA, por lo que ese requisito lo cumple holgadamente. Los pines de comunicación son SCL y SDA, que corresponden a la señal de reloj y a la línea de datos, respectivamente. El valor alto corresponde a una tensión Vin y el valor bajo corresponde a 0 V. 

\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.2]{images/imutrasera}
			\caption{IMU con los nombres de los pines.}
			\label{fig:pinesimu}
\end{figure}

El pin Vdd corresponde a una fuente de tensión de 3.3 V para otros componentes conectados al circuito, por lo que en ete trabajo se dejarán al aire. El pin Vdd corresponde a una fuente de tensión de 3.3 V para otros componentes conectados al circuito, por lo que en ete trabajo se dejarán al aire. En la figura \ref{fig:arduino+imufritzing} se muestra el esquema del circuito conectado. 


\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.6]{images/arduino+imufritzing}
			\caption{Esquema del circuito.}
			\label{fig:arduino+imufritzing}
\end{figure}

Uno de los aspectos a tener en cuenta para identificar correctamente el ángulo medido es el sentido de los ejes en la IMU y la dirección en que incrementan y decrementan cuando la IMU gira. Se explicará mediante la figura \ref{fig:ejesimu}, que representa la conexión realizada en el brazo.

\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.3]{images/detalleimureal}
			\caption{Conexión de la IMU.}
			\label{fig:ejesimu}
\end{figure}

Teniendo una vista global de la conexión completa en la figura \ref{fig:esquemaycircuito}, en esta vista en detalle se sabe que el eje que se va a medir es el eje X. La flecha significa que en la dirección hacia la que apunta la flecha los valores del sensor crecen y en el sentido contrario decrecen.

\section{Giróscopo}
\label{sec:explicaciongiroscopo}

Es un sensor que sirve para medir la velocidad angular de un algún aparato o vehículo. En la figura \ref{fig:imagengiroscopo} se observa su estructura. Para medir la velocidad de giro utiliza los principios del momento angular. Como se indica en \cite{wikigiroscopo}, cuando el giróscopo se somete a un momento de fuerza que tiende a cambiar la orientación de su eje de rotación, éste cambia de orientación girando respecto a un tercer eje, perpendicular tanto a aquel respecto del cual se lo ha empujado a girar, como a su eje de rotación inicial. Si está montado sobre un soporte de Cardano\footnote{Es un mecanismo de suspensión consistente en dos aros concéntricos cuyos ejes forman un ángulo recto.} que minimiza cualquier momento angular externo, o simplemente gira libre en el espacio, el giroscópo conserva la orientación de su eje de rotación ante fuerzas externas que tiendan a desviarlo.


 \begin{figure}[!h]
		\centering
			\includegraphics[scale=0.5]{images/giroscopo}
			\caption{Giróscopo mecánico.}
			\label{fig:imagengiroscopo}
		
\end{figure}

Debido a los tamaños con los que se trabaja hoy en día en el campo de  la electrónica resulta imposible construir un giróscopo electrónico con la estructura de la figura \ref{fig:imagengiroscopo}, por lo que se suelen utilizar giróscopos denominados de estructura vibrante o de vibración de Coriolis. Como se indica en \cite[p. 2]{patentegiroscopo} funcionan como resultado de fuerzas de Coriolis desarrolladas que ocurren cuando una partícula experimenta movimiento lineal en un bastidor rotatorio de referencia.\\
\\
Conociendo los tipos de giróscopos y su funcionamiento ya se puede pasar a realizar el programa para tomar medidas con el giróscopo utilizado en este trabajo. El giróscopo integrado en la IMU utilizada es el L3GD20H de la marca STMicroelectronics, un giróscopo de 3 ejes con salida digital. Se comunica mediante el bus de comunicación serie $I^2$C. Como ya se ha comentado previamente el fabricante del giróscopo adquirido provee una librería para que la lectura de datos de los sensores de la IMU resulte más sencilla. A continuación se muestran los pasos a seguir para poder empezar a leer datos del sensor:

\begin{enumerate}


	
	\item {\bf Incluir la librería}: para poder utilizar las funciones y clases de datos definidas en la librería hay que incluir en el proyecto mediante un include.
	
	\item {\bf Declarar una variable}: en la librería hay definida una clase de datos llamada L3G que será la que usaremos para leer datos del giróscopo, por lo tanto hay que declarar una variable de este tipo para llamar a las funciones de la librería.
	
	\item {\bf Inicializar}: el giróscopo por defecto está configurado en modo "sleep"; hay que inicializarlo para poder empezar a leer datos. Además para poder comunicarse con Arduino hay que inicializar la comunicación serie.
	
	\item {\bf Lectura datos}: con los pasos previos ya realizados se pueden empezar a leer datos con la función \textit{read} definida en la librería.
	
\end{enumerate}

Un ejemplo de un programa mediante el que se podrían leer datos del giróscopo se muestra en el código \ref{cod:ejemplo1}. En él se han programado todos los pasos arriba mencionados para tomar medidas del giróscopo.



\begin{lstlisting}[caption=Ejemplo de programa para tomar medidas del giróscopo., label=cod:ejemplo1,style=Cnice]
#include <Wire.h>  							//Librería para la comunicación serie
#include <L3G.h>	  							//Librería del giróscopo

L3G gyro;		  							//Declaración variable del tipo L3G

void setup()
{
  Serial.begin(115200); 						//Inicia el puerto serie
  Wire.begin();		   						//Comunicación I2C entre IMU y Arduino
  
   if (!gyro.init())	   						//Inicialización del giróscopo
  {
    Serial.println("Failed to autodetect gyro type!");
    while (1);
  }

  gyro.enableDefault();//Habilita varios registros a su valor por defecto
  
  }
  
void loop()
{
	gyro.read();
}

\end{lstlisting}

Estos valores leídos del sensor y almacenados en la variable gyro son valores ``raw``, es decir, es un entero de 16 bits, no la velocidad angular. Para obtener la velocidad angular hay que realizar una serie de operaciones especificadas por el fabricante en la hoja de características del sensor. Para obtener valores de velocidad angular se debe multiplicar el valor ``raw`` obtenido  por un factor de conversión llamado sensibilidad, cuyas unidades son mdps\footnote{mdps hace referencia a milidegrees per second (miligrados por segundo)}/digit. Los valores de estas constantes para cada FS se encuentran en \cite[p. 10]{hoja}. El objetivo final no es obtener la velocidad angular sino la posición, que es el ángulo. Como la velocidad es la derivada de la posición respecto del tiempo la solución es aplicar la ecuación \ref{ecuacion1} para obtener la posición.


\begin{equation}
  angulo = \int dps\_y\, dt
  \label{ecuacion1}
\end{equation}

Para poder programar esa integral hay que controlar el tiempo que tarda en ejecutarse el bucle principal, que debe ser siempre el mismo. Se debe medir el tiempo al inicio del bucle y al final del bucle para asegurarse de que en ninguna iteración se sobrepasa el tiempo de ejecución y si está por debajo introducir un delay. Para medir el tiempo transcurrido se puede utilizar la función ``millis()``. 



\begin{lstlisting}[caption=Ejemplo para obtener una medida de la posición., label=cod:ejemplo2,style=Cnice]
#include <Wire.h>  							
#include <L3G.h>	  							

#define FACTOR_CONVERSION_245DPS 0.00875

#define DT 0.03 							//Tiempo en segundos

int16_t dps_x;
unsigned long time_loop1, time_loop2;	//Variables para medir el tiempo de ejecución
double angulo_giroscopio_x;

...
  
void loop()
{

	time_loop1 = millis();
	gyro.read();
	
	dps_x =  (gyro.g.x)*FACTOR_CONVERSION_245PS;
	angulo_giroscopio_x += (double) dps_x*DT; 		//La integral se realiza mediante una multiplicación
	
	time_loop2 = millis();
	
	while(time_loop2-time_loop1 < DT) 
  {
    delay(1);
  }
}

\end{lstlisting}

Con el código \ref{cod:ejemplo2} ya se obtiene una estimación del ángulo del brazo, sin embargo esa medida tiene fuentes de error que hacen que la precisión de la medida sea muy baja. Hay métodos para minimizar estos errores pero no se pueden eliminar completamente. A continuación se comentan estos errores y cómo reducirlos.


\subsection{Fuentes de error}
\label{subsec:errores}

\subsubsection{Offset}

Este error se refiere al valor que dan los sensores si el brazo está parado, es decir, la velocidad angular es 0. Para corregirlo basta con estimarlo y restárselo a cada lectura. 


\begin{lstlisting}[caption=Eliminación del error de offset del giróscopo., label=cod:ejemplo3,style=Cnice]
#include <Wire.h>  							
#include <L3G.h>	  							

#define FACTOR_CONVERSION_245DPS 0.00875

#define DT 0.03 							//Tiempo en segundos

int16_t dps_x;
int sampleNum = 500, offsetg_x = 0;;


void setup()
{

for(int n=0;n<sampleNum;n++){
  
  gyro.read();
  offsetg_x+=(int)gyro.g.x;
}
offsetg_x = offsetg_x/sampleNum;

}

  
void loop()
{
	gyro.read();
	dps_x =  (gyro.g.x-offsetg_y)*FACTOR_CONVERSION_245PS;
	...
}

\end{lstlisting}

Mediante el código \ref{cod:ejemplo3} se obtiene la media del offset en sampleNum muestras y se consigue hacer despreciable el error de offset.

\subsubsection{Deriva (Drift)}

Para obtener la estimación del ángulo hay que realizar una integral, esto significa que cada iteración se suma un nuevo valor a la variable en la que se almacena el ángulo. Esta característica de la medida del ángulo provoca que si en cada medida hay un error pequeño se va a ir acumulando y tras varios segundos de ejecución de programa las medidas no van a ser válidas. En el caso del programa \ref{cod:ejemplo2} se suma ese error cada 30 ms, lo que hace que tras 10 segundos de ejecución se haya sumado ese error 333 veces.\\
\\
La única manera de reducir este error usando solo el giróscopo son los filtros paso-alto que incluye el modelo de giróscopo utilizado. Mediante este filtro se eliminan de la medida las muestras que tengan un valor muy pequeño como es el error por deriva. A pesar de utilizar este filtro no se consigue una medida válida de la posición del brazo; es necesario utilizar el acelerómetro para que la medida del ángulo sea precisa. La manera en la que se combinan los valores de los dos sensores se explicará en la sección \ref{sec:filtros}. 

\subsubsection{Precisión}

Además de los dos errores ya comentados hay otra característica del giróscopo, que no se puede considerar error pero sí limita la estimación del ángulo, y es que como este sensor mide la velocidad angular y ésta se integra la precisión de la medida es muy mala para movimientos lentos del brazo. Si la velocidad angular es muy baja el término que se va a sumar al ángulo es muy pequeño comparado con la suma total y no se va a percibir.

\subsection{Medidas}

En este apartado se van a mostrar ejemplos de medidas tomadas con los programas escritos en la sección \ref{sec:explicaciongiroscopo}. Las pruebas realizadas consisten en medir el ángulo con estos programas para poder observar las fuentes de error descritas en la sección \ref{subsec:errores}. La primera prueba consiste en ejecutar el programa y dejar el brazo en reposo para comprobar si se produce error por deriva. La segunda prueba consiste en mover el brazo un ángulo conocido para comprobar la precisión de la medida.


\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/angulogiroscoposinfiltro}
    \caption{Angulo medido con el giróscopo sin filtro.}
  \end{subfigure}  
      \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/angulogiroscopoconfiltro}
    \caption{Angulo medido con el giróscopo con filtro.}
  \end{subfigure}
  \caption{Resultados de la medida del ángulo con el giróscopo.}
  \label{fig:resultadosmedidagiroscopo}
\end{figure}

\paragraph*{}

Se puede observar perfectamente el error de deriva, en menos de un minuto el error en la medida es de 7º, que es un error intolerable si se pretende estabilizar el brazo. Además en el caso del filtro esos picos que se producen como el del segundo 20 son correcciones del filtro ante el pequeño incremento, pero la utilización del filtro no es suficiente para obtener una medida adecuada.

 \begin{figure}[!h]
		\centering
			\includegraphics[scale=0.58]{images/angulogiroscopovariacion90grados}
			\caption{Ángulo medido con el giróscopo variando el ángulo.}
			\label{fig:angulovariable}
		
\end{figure}

\paragraph*{}

La variación máxima real del ángulo es de 110º y después se ha vuelto a la posición inicial. El ángulo medido por el giróscopo es de 140º. Este error se debe a la baja precisión del giróscopo y a su principio de medida, que no le permite medir ángulos absolutos sino variaciones del ángulo. 


\section{Acelerómetro}
\label{sec:explicacionacelerometro}

Es cualquier instrumento destinado a medir las fuerzas de aceleración. Como se indica en \cite[p. 2]{analisisacelerometro}, hay muchas maneras diferentes de fabricar un acelerómetro. Algunos acelerómetros usan el efecto piezo-resistivo (contienen cristales microsópicos que se estiran debido a la aceleración y generan una tensión), otro tipo de tecnología es medir los cambios en la capacidad. Este último es el caso del acelerómetro utilizado , que utiliza la tecnología de fabricación MEMS\footnote{Sistemas Microelectromecánicos}. Estos acelerómetros están compuestos de una masa móvil con unas placas que están unidas mediante un sistema de suspensión mecánica a un marco de referencia, como se muestra en la figura \ref{fig:acelerometromems}. Las placas móviles y las placas exteriores fijas forman condensadores. La desviación de la masa se mide usando la diferencia de capacidades.


\begin{figure}[!h]
		\centering
			\includegraphics[scale=0.4]{images/acelerometromems}
			\caption{Acelerómetro de estructura vibrante.}
			\label{fig:acelerometromems}
		
\end{figure}

Conociendo los tipos de acelerómetros y su funcionamiento ya se puede pasar a realizar el programa para tomar medidas con el modelo del acelerómetro utilizado en este trabajo. El modelo integrado en la IMU utilizada es el LSM303D de la marca STMicroelectronics, un acelerómetro de 3 ejes con salida digital. Se comunica mediante el bus de comunicación serie $I^2$C. Como ya se ha comentado previamente el fabricante del acelerómetro adquirido provee una librería para que la lectura de datos de los sensores de la IMU resulte más sencilla. A continuación se muestran los pasos a seguir para poder empezar a leer datos del sensor:
 
\begin{enumerate}


	
	\item {\bf Incluir la librería}: para poder utilizar las funciones y clases de datos definidas en la librería hay que incluir en el proyecto mediante un include.
	
	\item {\bf Declarar una variable}: en la librería hay definida una clase de datos llamada LSM303 que será la que usaremos para leer datos del acelerómetro, por lo tanto hay que declarar una variable de este tipo para llamar a las funciones de la librería.
	
	\item {\bf Inicializar}: el acelrómetro por defecto está configurado en modo "sleep"; hay que inicializarlo para poder empezar a leer datos. Además para poder comunicarse con Arduino hay que inicializar la comunicación serie.
	
	\item {\bf Lectura datos}: con los pasos previos ya realizados se pueden empezar a leer datos con la función \textit{read} definida en la librería.
	
\end{enumerate}

Un ejemplo de un programa mediante el que se podrían leer datos del acelrómetro se muestra en el código \ref{cod:ejemplo4}.



\begin{lstlisting}[caption=Ejemplo de programa para tomar medidas del acelerómetro., label=cod:ejemplo4,style=Cnice]
#include <Wire.h>  							//Librería para la comunicación serie
#include <LSM303.h>	  							//Librería del acelerómetro

LSM303 compass;		  							//Declaración variable del tipo LSM303

void setup()
{
  Serial.begin(115200); 						//Inicia el puerto serie
  Wire.begin();		   						//Comunicación I2C entre IMU y Arduino
  
  compass.init();								//Inicialización del giróscopo
  compass.enableDefault();   					//Habilita varios registros a su valor por defecto
  }
  
  
void loop()
{
	compass.read();
}

\end{lstlisting} 
 
 Estos valores leídos del sensor y almacenados en la variable \textit{compass} son valores ``raw``, es decir, es un entero de 16 bits, no las fuerzas debidas a la aceleración. Para obtener la fuerza debida a la aceleración hay que realizar una serie de operaciones especificadas por el fabricante en la hoja de características del sensor. Para obtener valores de fuerza, medidos en g, se debe multiplicar el valor ``raw`` obtenido  por un factor de conversión llamado sensibilidad de aceleración lineal, cuyas unidades son mg\footnote{mg hace referencia a miligauss}/LSB. Los valores de estas constantes para cada FS se encuentran en \cite[p. 10]{hojab}. El procedimiento para obtener las fuerzas de aceleración es idéntico al que se ha llevado a cabo para obtener la velocidad angular con el giróscopo. Sin embargo, el objetivo final no es obtener las fuerzas de aceleración sino la posición, que es el ángulo. El ángulo se obtiene mediante los ángulos de Euler, que consiste en resolver unas matrices de rotación cuya solución son los ángulos de inclinación de un sólido rígido. La resolución de estas matrices se ha consultado en el documento del fabricante Freescale Semiconductor \cite[p. 10]{calculoangulosacelerometrofreescale}. La ecuación usada para estimar el ángulo es la ecuación \ref{ecuacion2}, que en el documento equivale a la ecuación 37:
 
 
 \begin{equation}
  tan(angulo\_acelerometro\_y) = {\displaystyle {{{-fuerza\_x} \over {\sqrt{fuerza\_y^2+fuerza\_z^2}}}}}
  \label{ecuacion2}
\end{equation}

El resultado está en radianes, así que hay que pasarlo a grados con una constante que se llamará \textit{RAD\_TO\_DEG} y cuyo valor es ${180 \over 2\pi} = 57.2958$. Mediante este método sólo se obtienen ángulos entre -90º y +90º. Dado que el brazo sólo puede girar en un rango de entre -75º y +75º, el rango de medidas mediante este método es válido para este trabajo.\\

El programa para implementar esa ecuación es más sencillo que el programa necesario para estimar los ángulos mediante el giróscopo, pues en el caso del acelerómetro sólo hay que implementar una multiplicación. El código \ref{cod:ejemplo5} implementa todos los pasos necesarios para estimar el ángulo mediante el acelerómetro.

\begin{lstlisting}[caption=Estimación del ángulo mediante el acelerómetro., label=cod:ejemplo5,style=Cnice]
#include <Wire.h>  							//Librería para la comunicación serie
#include <LSM303.h>	  							//Librería del acelerómetro

#define RAD_TO_DEG 57.2958
#define FACTOR_CONVERSION_2G 0.000061


LSM303 compass;		  							//Declaración variable del tipo LSM303
double fuerza__x, fuerza_y, fuerza_z;
double angulo_acelerometro_x, raiz_x;
...
  
  
void loop()
{
	compass.read();
	
	fuerza_x =  -((compass.a.x)*FACTOR_CONVERSION_2G);//El signo - es debido a que la IMU está invertida 
  	fuerza_y =  -((compass.a.y)*FACTOR_CONVERSION_2G);
  	fuerza_z =  -((compass.a.z)*FACTOR_CONVERSION_2G);
  	
  	raiz_x = sqrt((fuerza_x*fuerza_x)+(fuerza_z*fuerza_z)); 
	
	angulo_acelerometro_x = (atan2(fuerza_y,raiz_x))*RAD_TO_DEG;
}

 \end{lstlisting} 
 
Con el código \ref{cod:ejemplo5} ya se obtiene una estimación del ángulo del brazo, sin embargo esa medida tiene fuentes de error que hacen que la precisión de la medida sea muy baja. Hay métodos para minimizar estos errores pero no se pueden eliminar completamente. A continuación se comentan estos errores y cómo reducirlos. 
 

\subsection{Fuentes de error}
\label{subsec:erroresacelerometro}

\subsubsection{Offset}

Este error se refiere al valor que dan los sensores si la fuerza en un eje es 0. Para corregirlo basta con estimarlo y restárselo a cada lectura. 


\begin{lstlisting}[caption=Eliminación del error de offset del acelerómetro., label=cod:ejemplo6,style=Cnice]
#include <Wire.h>  							
#include <LSM303.h>	  							

#define FACTOR_CONVERSION_2G 0.000061

double fuerza_x;
int sampleNum = 500, offset_x = 0;;


void setup()
{

for(int n=0;n<sampleNum;n++){
  
  compass.read();
  offsetg_x+=(int)compass.a.x;
}
offset_x = offset_y/sampleNum;

}

  
void loop()
{
	compass.read();
	fuerza_x =  -((compass.a.x-offseta_x)*FACTOR_CONVERSION_2G);
	...
}

\end{lstlisting}

Mediante el código \ref{cod:ejemplo6} se obtiene la media del offset en sampleNum muestras y se consigue hacer despreciable el error de offset restando el valor de offset al valor de cada medida.
 
 

\subsubsection{Ruido}
 
 En el caso del giróscopo se necesitaba movimiento del aparato en el que está acoplado el sensor para poder medir el ángulo, sin embargo con el acelerómetro se puede medir el ángulo en cualquier momento. El problema es que las medidas del acelerómetro introducen un ruido de baja frecuencia que provoca que no se pueda medir el ángulo con precisión en un corto período de tiempo. Las medidas del acelerómetro son útiles sólo para medir ángulos en un largo periodo de tiempo y de variaciones lentas. No hay manera de eliminar este error si sólo se usa para medir el acelerómetro. Para ello se combinan las medidas del acelerómetro y del giróscopo utilizando filtros. 
 
 
\subsection{Medidas}

En este apartado se van a mostrar ejemplos de medidas tomadas con los programas escritos en la sección \ref{sec:explicacionacelerometro}. Las prueba realizada consiste en medir el ángulo con estos programas para poder observar las fuentes de error descritas en la sección \ref{subsec:erroresacelerometro}. 

\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.5]{images/anguloacelerometro}
  \caption{Resultados de la medida del ángulo con el acelerómetro.}
  \label{fig:resultadosmedidaacelerometro}
\end{figure}

Esta prueba realizada es similar a la realizada al medir con el giróscopo y variar el ángulo. Como se ve en la gráfica\ref{fig:resultadosmedidaacelerometro}, al contrario de lo que sucedía con el giróscopo (cuyo punto de referencia estaba donde empezaba el brazo), los resultados ahora son de ángulos absolutos entre .90º y +90º, siendo 0º el ángulo en el que el brazo está paralelo al suelo. También se aprecia en la gráfica el error debido al ruido, cuando se produce un cambio brusco del ángulo de inclinación el ruido que aparece en las medidas es considerable. Ante cambios lentos del ángulo la precisión es elevada, pero es debido a las posibles variaciones rápidas del ángulo que se debe usar el giróscopo en conjunto. Para cuantificar mejor si ese ruido que aparece es importante se muestra en la figura \ref{fig:detalleruido} una ampliación de la anterior imagen.


\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.5]{images/anguloacelerometrodetalle}
  \caption{Ruido en la medida del ángulo con el acelerómetro.}
  \label{fig:detalleruido}
\end{figure}

 Las variaciones del ángulo son de hasta 5º para un ángulo medido de 75º, si el ángulo fuese más pequeño, por ejemplo 10º, el error sería mucho mayor y correspondería a un 50 \% de su valor. Con este error resultaría muy complejo estabilizar el brazo, es necesario el uso de filtros que cobinen adecuadamente las medidas del acelerómetro y del giróscopo. Los distintos tipos de filtros se explicarán en la sección \ref{sec:filtros}.
 
 
 
\section{Filtros}
\label{sec:filtros}

Para que la medida del ángulo tenga una precisión suficiente para poder estabilizar el brazo es necesario combinar las medidas de los dos sensores explicados hasta ahora, el acelrómetro y el giróscopo. Esa es la utilidad de los filtros, mediante un algoritmo combina las medidas de ambos sensores para reducir o eliminar los errores típicos de cada sensor y dar una medida de alta precisión del ángulo. Los dos filtros más comunes y que mejor funcionan son el filtro de Kalman y el filtro complementario.



\subsection{Filtro de Kalman}
\label{subsec:filtrokalman}

Este es el filtro más eficaz pero también el más complejo de implementar. Es un filtro recursivo que predice el error y lo corrige teniendo únicamente como datos las mediciones de entrada actuales, el estado calculado previamente y su matriz de incertidumbre. Para implementarlo se utiliza el control en el espacio de estados.

\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.8]{images/kalman}
  \caption{Algoritmo recursivo del filtro de Kalman.}
  \label{fig:kalman}
\end{figure}

\paragraph*{}

Este filtro, debido a que trabaja con matrices, requiere mucha potencia de cálculo y el Arduino Uno no tiene un procesador muy potente. 


\subsection{Filtro complementario}
\label{subsec:filtrocomplementario}

El concepto del filtro complementario consiste en tomar las variaciones lentas del acelerómetro y las variaciones bruscas del giróscopo y combinarlas. El acelerómetro da buenas medidas de la posición en condiciones estáticas y el giróscopo las da en condiciones dinámicas, es decir, cuando el brazo se mueve rápido. La implementación de este filtro se realiza pasando las medidas del acelerómetro por un filtro paso-bajo y las medidas del giróscopo por un filtro paso-bajo y combinar el resultado para obtener la posición final. La implementación se realiza con una línea de código en el bucle principal, mostrada en el código \ref{cod:ejemplo7}.


\begin{lstlisting}[caption=Línea de código para implementar el filtro complementario., label=cod:ejemplo7,style=Cnice]
angulo_x = 0.95*(angulo_x + dps_x*DT) + 0.05*angulo_acelerometro_x; 
	
\end{lstlisting}

Teniendo los valores de los ángulos medidos con el giróscopo y el acelerómetro se introduce esa línea de código en el bucle principal y se obtiene una medida precisa del ángulo. Los valores de los filtros se pueden ajustar experimentalmente para obtener los mejores resultados. \\
\\
Dado que la implementación de este filtro es muy simple y los resultados son satisfactorias para la obtención del ángulo del brazo se va a utilizar el \textbf{filtro complementario}.
\subsection{Medidas}

En este apartado se va a mostrar cómo los errores mostrados en los apartados del acelerómetro y del giróscopo se eliminan mediante el uso del filtro complementario. Los distintos experimentos realizados mostrarán la efectividad del filtro y la precisión en las medidas del ángulo del brazo.\\
\\
El primer experimento consiste en dejar el brazo en reposo y registrar los ángulos del giróscopo y del acelerómetro y después obtener el del filtro complementario. El propósito de esta prueba es observar si el filtro corrige la deriva del giróscopo y si la medición del ángulo es correcta.\\



\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.57\textwidth}
    \includegraphics[width=\textwidth]{images/filtroreposo}
    \caption{Medidas del ángulo.}
  \end{subfigure}  
      \begin{subfigure}{0.4\textwidth}
    \includegraphics[width=\textwidth]{images/reposoreal}
    \caption{Inclinación del brazo.}
  \end{subfigure}
  \caption{Resultados de la medida del ángulo con el giróscopo.}
  \label{fig:derivafiltrocomplementario}
\end{figure}


La figura \ref{fig:derivafiltrocomplementario} muestra cómo en la medida del filtro no hay deriva y además da una medida absoluta y precisa del ángulo. Cuando la variación del ángulo es pequeña el filtro paso-alto aplicado al giróscopo desprecia la medida del giróscopo , teniendo en cuenta únicamente la medida del acelerómetro. 

El segundo experimento consiste en mover el brazo manualmente para comprobar los resultados de la medida del giróscopo, el acelerómetro y la combinación de ambos con el filtro complementario.

\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.36]{images/filtromovil}
  \caption{Medida del ángulo moviendo el brazo.}
  \label{fig:brazomovil}
\end{figure}

\newpage

En la figura \ref{fig:brazomovil} se observa cómo el resultado obtenido con el filtro complementario sigue a las medidas dadas por el acelerómetro pero filtrando el ruido. Además también se comprueba que el giróscopo mide correctamente cuando el brazo se está moviendo, aunque no sea en valores absolutos las variaciones las mide correctamente y no aparece deriva al no estar el brazo en reposo durante varios segundos.



\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/filtromovilrojo}
    \caption{Medidas del ángulo.}
  \end{subfigure}  
      \begin{subfigure}{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/filtromovildetalleruido}
    \caption{Inclinación del brazo.}
  \end{subfigure}
  \caption{Resultados de la medida del ángulo con el giróscopo.}
  \label{fig:detalleruido}
\end{figure}

Para observar el ruido se ha aumentado la imagen \ref{fig:brazomovil}. Se comprueba cómo para un ángulo real del brazo de 78º el ruido que introduce el acelerómetro provoca que éste mida 86º, siendo un error considerable. \\
\\
En este apartado se ha mostrado el principio de funcionamiento de cada sensor y se han enumerado los errores que tiene cada uno  al estimar el ángulo del brazo. Se ha mostrado experimentalmente la eficacia del filtro complementario, que corrige los errores típicos de cada filtro con una sola línea de código y requiriendo poco tiempo de cómputo, lo que hace que sea una buena opción utilizar este filtro en aplicaciones en las que no se disponga de un procesador muy potente.


\part{Motores y ESC}
\label{part:motoresyesc}

\chapter{Motores y ESC}
\label{chapter:motoresyesc}


\section{Introducción}
\label{sec:introduccionmotoresyesc}

Los motores acoplados a los extremos del brazo van a ser los actuadores mediante los que se va a estabilizar el ángulo. Ya que el brazo sólo puede moverse en dos direcciones de un solo eje se necesitan dos motores. Ya se ha explicado en el apartado \ref{sec:ESC} la razón de utilizar los controladores electrónicos de velocidad (ESC), en este apartado se explicará cuál debe ser la conexión entre los motores y el ESC y entre éstos y el Arduino.

\section{Conexión de los motores y los ESC}
\label{sec:conexionmotoresyesc}

El esquema de la conexión, realizado con Fritzing \cite{fritzing}, entre batería, ESC, Arduino y los motores se muestran en la figura \ref{fig:esquemafritzing}.


\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.5]{images/circuitofritzing}
  \caption{Esquema de conexión motores.}
  \label{fig:esquemafritzing}
\end{figure}

Sólo se muestra un motor porque la conexión del otro es idéntica. Como los motores giran a muchas revoluciones y las hélices tienen una sección muy fina son peligrosas cuando están en movimiento. Para asegurarse de que no les está llegando corriente a los motores y no van a empezar a girar se ha conectado un LED verde que se encenderá cuando se conecte el interruptor de la batería. La señal de control del ESC debe llevarse a una salida digital y la masa de los pines de control del ESC debe conectarse al pin GND del Arduino. {\bf Nunca se debe conectar el pin rojo de la señal de control al pin de 5 V del Arduino}. Como se indica en \cite{proteccionarduino} no hay protección frente en ese pin del Arduino. Este pin está conectado directamente al microcontrolador ATmega328, la interfaz de USB del microcontrolador y al regulador de 5 V, siendo la tensión máxima soportada por todos ellos 6 V. \\

Antes de conectar los motores hay que asegurarse de que ambos giran en el mismo sentido. Si cada motor gira en un sentido ambos motores van a empujar al brazo en la misma dirección, siendo imposible estabilizarlo una vez pasado el punto de equilibrio. Si por ejemplo el motor izquierdo empuja el brazo hacia arriba y el motor derecho empuja el brazo hacia abajo sólo se puede actuar sobre el brazo girándolo hacia la derecha. Si la conexión realizada hace girar a cada motor en un sentido sólo se debe {\bf intercambiar la conexión de dos fases} en un motor y el problema está solucionado.\\

\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.13]{images/detallefases}
  \caption{Fases intercambiadas en uno de los motores.}
  \label{fig:cambiofases}
\end{figure}


Con las conexiones de los motores ya realizadas se pueden empezar a realizar pruebas con los motores para conocer su funcionamiento con el objetivo de que los reguladores que se implementen tengan un funcionamiento óptimo.



\section{Regulación de velocidad de los motores}
\label{sec:regulacionvelocidad}

La señal mediante la que se regulan los motores es una señal PPM (pulse position modulation), como se ha explicado en la sección \ref{sec:ESC}. Este apartado se va a centrar en explicar cómo se realiza el programa necesario para generar esas señales y enviarlas al ESC. Tiene varias modos de funcionamiento, entre los que se incluye el modo acelerador o \textit{throttle} y el modo freno. Para que los motores se muevan se debe programar el ESC en modo \textit{throttle}. Una peculiaridad de estos controladores es que la elección del modo de funcionamiento se realiza mediante sonidos, justo después de escuchar el sonido asociado al modo de funcionamiento que se quiere elegir se debe enviar la señal mínima al controlador y el ESC quedará programado en ese modo. El modo \textit{throttle} corresponde al segundo sonido emitido por el ESC, el primero indica que está conectado. Para enviar señales al ESC se debe hacer como si fuese un servo, utilizando la librería servo de Arduino. Los pasos necesarios para llegar a arrancar un motor son los siguientes:

\begin{enumerate}
	
	\item {\bf Incluir la librería}: para poder utilizar las funciones y clases de datos definidas en la librería servo hay que incluirla en el proyecto. 
	
	\item {\bf Declarar una variable}: en la librería servo hay una clase de datos llamada \textit{servo}, hay que declarar una variable por cada motor.
	
	\item {\bf ''Adjuntar'' el motor}: mediante la función \textit{attach} declarada en la librería servo se especifica en qué pin está conectado cada motor.
	
	\item {\bf Programación del ESC}: para iniciar el modo programación del ESC hay que escribir la señal máxima de los motores, que son 2 ms.
	
	\item {\bf Elección modo \textit{throttle}}: el modo de funcionamiento se elige mediante sonidos, cuando se oiga el sonido asociado al modo en el que se quiere trabajar se quiere enviar la señal mínima, que son 0.7 ms.
	
	\item {\bf Escribir un valor de velocidad en los motores}: el último paso es escribir el valor de velocidad a la que se quiere que giren los motores, ese valor deberá estar comprendido entre 1 y 2 ms.
	
\end{enumerate}

Un ejemplo de un programa mediante el que se arrancan los motores se muestra en el código \ref{cod:ejemplo10}. En él se han programado todos los pasos arriba mencionados para poder la velocidad de los motores.



\begin{lstlisting}[caption=Ejemplo de programa para arrancar los motores., label=cod:ejemplo10,style=Cnice]
#include <Servo.h>  							//Librería para para controlar un servo


#define MAX_SIGNAL                 2000
#define MIN_SIGNAL                 700 

#define MOTOR_IZQUIERDO_PIN        9     

Servo motorizquierdo;				//Definición de la variable para poder adjuntar el motor
int velocidad_motor_izquierdo;

void setup()
{
	//Adjuntar el motor, se asocia la variable motorizquierdo con el motor conectado al pin 9
		motorizquierdo.attach(MOTOR_IZQUIERDO_PIN); 
     
    //Ahora se debe entrar en modo programación, para lo que se escribe la señal máxima en el ESC
     	motorizquierdo.writeMicroseconds(MAX_SIGNAL);

    // Esperando a que se pulse una tecla
      	while (!Serial.available());
      	Serial.read();

    // Enviar valor minimo 
    		motorizquierdo.writeMicroseconds(MIN_SIGNAL)
  }
  
void loop()
{
	velocidad_motor_izquierdo = 1300;
	motorizquierdo.writeMicroseconds(velocidad_motor_izquierdo);
}
\end{lstlisting}


El bucle while de la línea 18 está ejecutándose hasta que se pulse una tecla cualquiera. Se coloca para que cuando se escuche el sonido correspondiente al modo de funcionamiento del controlador con el que se quiere trabajar se pulse cualquier tecla y el programa siga ejecutándose. Para mandar un valor de velocidad al controlador se utiliza la función \textit{writeMicroseconds}. Como el valor pasado son microsegundos hay que multiplicar por 1000 el valor de milisegundos correspondiente.




\part{Estabilización del brazo}
\label{part:reguladores}

\chapter{Estabilización del brazo}
\label{chapter:reguladores}

\section{Introducción}
\label{sec:introduccionreguladores}

Hasta este punto el trabajo se ha centrado en estudiar los componentes y cómo utilizarlos para tomar medidas en l caso de los sensores y variar su velocidad en el caso de los motores, pero no se ha aplicado ningún control sobre ningún componente. En este apartado se va a aplicar la teoría de control implementando distintos controladores para estabilizar el brazo en un ángulo que será indicado al sistema como referencia.


\section{Controladores}
\label{sec:controladores}

Un controlador tiene la función de mantener constante una característica determinada del sistema. En este caso se mantendrá constante el ángulo del brazo midiendo la posición mediante la IMU y actuando mediante los motores cuando haya error. Existen muchos controladores pero los más comunes son los controladores PID. en este trabajo se implementarán, además del controlador PID, otros controladores para comprobar cómo mejoran o empeoran la respuesta del sistema en lazo cerrado respecto al controlador PID. Se probarán los controladores PPI, PIP, PIDPID. Para cada controlador se realizarán pruebas experimentales variando los valores de las constantes y midiendo parámetros que determinan la calidad de la respuesta como el tiempo de establecimiento, el tiempo de subida... En adelante se explicará cómo implementarlos y se mostrarán los resultados de cada uno.


\subsection{PID}
\label{sec:controladorpid}

Es un mecanismo de control sobre un bucle de control por realimentación. Consiste en una combinación de 3 controladores independientes. Estos 3 controladores en conjunto procesan el error calculado a partir de la señal de referencia menos la señal de salida real. Con cada uno de los controladores se mejora uno de los dos regímenes de un sistema de control, bien la respuesta en régimen transitorio o bien la respuesta en régimen permanente, mejorando la estabilidad, la precisión y la velocidad de respuesta. Como se indica en \cite[p. 669]{ogata}, el algoritmo del control PID consiste en la suma de los tres controladores mencionados, su esquema se muestra en la figura \ref{fig:pid}.

\newpage 

\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.5]{images/PIDdesglose}
  \caption{Esquema del sistema.}
  \label{fig:pid}
\end{figure}


Cada controlador puede expresarse de distinta manera en función de si se trabaja en el dominio de Laplace o en el dominio del tiempo, aplicando las propiedades de la transformada de Laplace se pasará del dominio del tiempo al dominio de Laplace para mostrar ambas expresiones:

\begin{itemize}

		\item {\bf Proporcional}: su respuesta es proporcional al error. Si sólo se utiliza este controlador hay mucho ruido en el sistema y el sistema oscilaría mucho hasta estabilizarse. A mayor valor de la constante $K_p$ mejor es la precisión y peor es la estabilidad, es decir, mejor es la respuesta en régimen permanente y peor es la respuesta en régimen transitorio.
		
\begin{equation}
  {u(t) \over e(t)} = K_p 
  \label{ecuacion11}
\end{equation}

\begin{equation}
  {U(s) \over E(s)} = K_p 
  \label{ecuacion12}
\end{equation}

		
		
		\item {\bf Integral}: su respuesta es proporcional a la integral del error, es decir, a la variación del error. Se puede considerar una memoria que estima lo que va a pasar en función de los errores pasados. Elimina el error en régimen estacionario a costa de aumentar el tiempo de establecimiento y hacer la respuesta más lenta.
		
\begin{equation}
  u(t) = K_i \int_{0}^{t}e(\tau)\, d\tau
  \label{ecuacion11}
\end{equation}

Por la propiedad de la integral de la tabla de propiedades de la transformada de Laplace se sabe que una integral en el dominio del tiempo equivale a una división por \textit{s} en el dominio de Laplace, por lo tanto:
\begin{equation}
  {U(s) \over E(s)} = {K_i \over s} =  K_p {1 \over T_i s}
  \label{ecuacion12}
\end{equation}

				
		
		\item {\bf Derivativo}: su respuesta es proporcional a la derivada del error, es decir, a la velocidad de variación del error. El efecto derivativo mejora la respuesta transitoria del sistema pero empeora la respuesta en régimen permanente. En particular aumenta la velocidad de respuesta del sistema pero introduce ruido a alta frecuencia, que se disminuye mediante la acción del proporcional.
		
		
		\begin{equation}
  u(t) = K_d {de(t) \over dt}
  \label{ecuacion11}
\end{equation}

Por la propiedad de la derivada de la tabla de propiedades de la transformada de Laplace se sabe que una derivada en el dominio del tiempo equivale a una multiplicación por \textit{s} en el dominio de Laplace, por lo tanto:

\begin{equation}
  {U(s) \over E(s)} = K_d s =  K_p T_d s
  \label{ecuacion12}
\end{equation}


\end{itemize}

Teniendo la función de transferencia de cada controlador que compone el PID se puede obtener su función de transferencia sumando cada componente:

\begin{equation}
  PID = {U(s) \over E(s)} = P+I+D = K_p + {K_i \over s} + K_d s = K_p (1+{1 \over T_i s}+T_d s)
  \label{ecuacion12}
\end{equation}

Estas dos formas de representar la expresión de un PID se denominan paralela (la expresión que tiene las constantes K) y estándar (la expresión que incluye las constantes T_i y T_d ).\\

La entrada de referencia es el ángulo en grados al que se quiere estabilizar el brazo. Para estabilizar el brazo se va a establecer una velocidad base de 1,3 ms para cada motor, que será la velocidad a la que giren los motores si el error es nulo. Si hay error el PID actuará acelerando un motor y desacelerando el otro para corregirlo. Los pasos a seguir para implementar este controlador son:

\begin{enumerate}

	\item {\bf Definir las constantes}: hay que definir los valores de las constantes que se multiplicarán a cada parámetro del controlador, después se ajustarán experimentalmente.

	\item {\bf Calcular el error}: como ya se ha calculado el ángulo del brazo en el capítulo \ref{chapter:sensores} ahora se necesita un dato de entrada, el ángulo de referencia. Para empezar se escribirá en en el programa como un \textit{\# define}, más adelante se modificará desde LabView. Para calcular el error sólo hay que restar el ángulo de referencia al ángulo medido del brazo.
	
	\item {\bf Calcular el integral}: como el parámetro es una integral es imprescindible multiplicar por DT\footnote{Delta Time: es la duración del bucle principal en segundos} la suma del error.
	
	\item {\bf Calcular el derivativo}: ya que es una derivada hay que dividir por DT la resta del error actual y el error de la iteración anterior.
	
	\item {\bf Cálculo del PID}: teniendo los 3 parámetros hay que combinarlos todos en una única variable.
	
	\item {\bf Aplicar el control a los motores}: como se indica en la sección \ref{sec:conexionmotoresyesc} cada motor gira en un sentido, por lo tanto a un motor hay que sumar el valor del controlador y al otro restarlo.
	
\end{enumerate}


\begin{lstlisting}[caption=Implementación del PID., label=cod:ejemplo111,style=Cnice]
#include <Servo.h>  							
#include <Wire.h>
#include <LSM303.h>
#include <L3G.h>

#define DT 0.03 
#define ANGULO_REFERENCIA = 0; //Ángulo al que se quiere estabilizar el brazo

#define MAX_SIGNAL                 2000
#define MIN_SIGNAL                 700 
#define MAX_VEL                    1500	
#define MIN_VEL                    1000 

#define MOTOR_IZQUIERDO_PIN        9
#define MOTOR_DERECHO_PIN          10    

#define Throttle_Motor_Izquierdo   1300   //Velocidad de los motores si el error es 0
#define Throttle_Motor_Derecho     1300 

double angulo_x;

//VARIABLES MOTORES

Servo motorizquierdo, motorderecho;		
int velocidad_motor_izquierdo, velocidad_motor_derecho;

//VARIABLES PID

    float Kp = 6, Ki = 3, Kd = 2;  
    float error, error_pasado, derivativo, integral;
    float PID_angulo;

void setup()
{
	 	Serial.begin(115200);
    		Wire.begin(); 
	//Adjuntar motores, programar ESC's y habilitar sensores
			
		...
} 
void loop()
{
	//Medida ángulo
		...
	 angulo_x = 0.95*(angulo_x + dps_x*DT) + 0.05*angulo_acelerometro_x;	
	 
	//PID
		 
	 error = ANGULO_REFERENCIA - angulo_x; 
    	 integral+=(error*DT);
    	 derivativo = (error-error_pasado)/DT;
    	 PID_angulo = Kp*error + Ki*integral + Kd*derivativo;

	//Control motores
	
	 velocidad_motor_izquierdo = Throttle_Motor_Izquierdo + PID_angulo;
     velocidad_motor_derecho   = Throttle_Motor_Derecho - PID_angulo;
     
      velocidad_motor_izquierdo = (velocidad_motor_izquierdo > MAX_VEL) ? MAX_VEL:velocidad_motor_izquierdo;
     velocidad_motor_izquierdo = (velocidad_motor_izquierdo < MIN_VEL) ? MIN_VEL:velocidad_motor_izquierdo; //Velocidad minima para que no se pare el motor izquierdo
     
     velocidad_motor_derecho = (velocidad_motor_derecho > MAX_VEL) ? MAX_VEL:velocidad_motor_derecho;
     velocidad_motor_derecho = (velocidad_motor_derecho < MIN_VEL) ? MIN_VEL:velocidad_motor_derecho;//Velocidad minima para que no se pare el motor derecho
     
     motorizquierdo.writeMicroseconds(velocidad_motor_izquierdo);
     motorderecho.writeMicroseconds(velocidad_motor_derecho);
     
     error_pasado = error;	//Para calcular el derivativo 
}
\end{lstlisting}

El código \ref{cod:ejemplo111} muestra cómo se implementa el controlador PID. Las constantes MAX\_VEL y MIN\_VEL se utilizan para limitar la velocidad de los motores desde la línea 64 del código hasta la línea 69. Es recomendable para que la velocidad no sobrepase el límite, si desciende de 1 ms el motor se puede parar y si aumenta de 2 ms el motor puede llegar a romperse. Se ha establecido en 1,5 ms la máxima porque la fuente de alimentación no suministra suficiente corriente para llevar a un motor a la velocidad máxima mientras el otro sigue girando.\\
\\

Para comprobar cómo varía la respuesta en función de los valores de las constantes se van a realizar dos pruebas variando las tres constantes del controlador. El resultado de la estabilización con este controlador para las dos pruebas se muestra en la figura \ref{fig:escalonpid}. 


\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonpid}
    \caption{K_p = 6 - K_i = 3 - K_d = 2.}
  \end{subfigure}  
      \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonpid2}
    \caption{K_p = 5 - K_i = 0.5 - K_d = 4.}
  \end{subfigure}
  \caption{Respuesta del sistema para controlador PID.}
  \label{fig:escalonpid}
\end{figure}



El ruido presente en ambas respuestas tiene dos orígenes, el primero son las vibraciones provocadas por el giro de los motores, cuando el brazo llega al ángulo de referencia la vibración de los motores provoca un pequeño error que el controlador intenta corregir constantemente, y el segundo a la constante $K_d$ , aumentándola se consigue un mayor tiempo de respuesta pero también se introduce más ruido en el sistema. Sin embargo la magnitud de ruido introducida por los motores es mucho mayor que la que introduce el aumento de la constante ya que este último se puede contrarrestar (comose observa en la el caso (b)) mediante un buen ajuste de las constantes. En la figura \ref{fig:errorpid} se muestra la magnitud del ruido después del escalón.

\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonpiddetalle}
    \caption{K_p = 6 - K_i = 3 - K_d = 2.}
  \end{subfigure}  
      \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonpid2detalle}
    \caption{K_p = 5 - K_i = 0.5 - K_d = 4.}
  \end{subfigure}
  \caption{Detalle del ruido presente en la respuesta en régimen permanente del controlador PID.}
  \label{fig:errorpid}
\end{figure}

 
Mediante estas dos pruebas se comprueba cómo con un sencillo ajuste de las constantes se puede mejorar mucho la respuesta del sistema, tanto en régimen permanente como en régimen transitorio.\\
\\
Para poder comparar los resultados con el resto de controladores se van a calcular en la respuesta de cada controlador los parámetros en régimen transitorio. Para poder obtener el valor exacto de algunos de ellos es recomendable escribir un script de Matlab. El código \ref{cod:matlab1} permite obtener el tiempo de establecimiento, el tiempo de pico y el sobreimpulso máximo con exactitud.   


\lstset{language=matlab}
\lstset{tabsize=2}
\lstset{commentstyle=\textit}
\lstset{stringstyle=\ttfamily, basicstyle=\small}
\begin{lstlisting}[caption=Cálculo de parámetros en régimen transitorio con Matlab., label=cod:matlab1,frame=trbl]{}
 
 figure(1);
 plot(dt, angulomedido, dt, anguloreferencia);
 title('Respuesta al escalón');
 xlabel('Time[s]');
 ylabel('Ángulo[º]');
 legend('Ángulo medido', 'Ángulo de referencia');
 
 m = 1031;
 while angulomedido(m) > 27 & angulomedido(m) < 33
 	m = m-1;
 end
 Tiempo_de_establecimiento = dt(m)-9.5;
 [Mp, k] = max(angulomedido);
 Tiempo_de_pico = dt(k)-9.5;
 
 \end{lstlisting}

El valor de la variable \textit{m} tiene que ser el número de muestras de \textit{angulomedido}, se recorre el array \textit{angulomedido} desde la última muestra y cuando su valor deja de estar en el 10\% del ángulo de referencia. La constante 9.5 restada a los tiempos de establecimiento y de pico es el instante en que comienza el escalón, que es cuando hay que medir los parámetros. El tiempo de retardo y el tiempo de subida se puden obtener con el puntero de Matlab, situándose sobre el punto adecuado, el momento en que se llega al 50\% del valor del valor máximo en el caso del tiempo de retardo y el momento en el que se llega por primera vez al valor de escalón en elk caso del tiempo de subida. En el caso del controlador PID los valores de estos parámetros son:


\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Parámetros en régimen transitorio PID.}
  \label{table119}
  \begin{center}
            \begin{tabular}{|c|c|c|}
      \hline
      \rowcolor{LightBlue2} Parámetro & Caso (a) & Caso (b) \\
      \hline
      Tiempo de retardo ($t_d$) & 2 seg & 1.2 seg\\
      \hline
      Tiempo de subida ($t_r$) & 3 seg & 5.4 seg\\
      \hline
      Tiempo de pico ($t_p$) & 1.84  &  6.59 seg\\
      \hline
      Tiempo de establecimiento ($t_{s10\%}$) & 14.83 seg &  4.19 seg\\
      \hline
     Máximo sobreimpulso ($M_p$) & 41º (1.36) & 31º (1.03)\\
      \hline
    \end{tabular}
  \end{center}
\end{table}

\subsection{PPI}
\label{sec:controladorppi}

En este controlador se incluye un nuevo bucle de realimentación. Ahora se realimenta también la velocidad angular, que es la salida de la planta, para aplicar un regulador. El esquema de este regulador se muestra en la figura \ref{fig:ppi}


 \begin{figure}[!h]
  \centering
    \includegraphics[scale=0.8]{images/PPIdesglose}
  \caption{Esquema del controlador PPI.}
  \label{fig:ppi}
\end{figure}

Este controlador consiste en realimentar la salida en grados aplicándole al error un controlador proporcional y realimentar la salida de la planta en grados por segundo y al error aplicarle un controlador proporcional integral. La implementación de este controlador se realiza mediante el código \ref{cod:ejemplo1235}.


\begin{lstlisting}[caption=Implementación del PPI., label=cod:ejemplo1235,style=Cnice]
#include <Servo.h>  							
#include <Wire.h>
#include <LSM303.h>
#include <L3G.h>

#define DT 0.03 
#define ANGULO_REFERENCIA = 0; //Ángulo al que se quiere estabilizar el brazo

#define MAX_SIGNAL                 2000
#define MIN_SIGNAL                 700 

#define MAX_VEL                    1500	
#define MIN_VEL                    1000 

#define MOTOR_IZQUIERDO_PIN        9
#define MOTOR_DERECHO_PIN          10    

#define Throttle_Motor_Izquierdo   1300   //Velocidad de los motores si el error es 0
#define Throttle_Motor_Derecho     1300 

double angulo_x;

//VARIABLES MOTORES

Servo motorizquierdo, motorderecho;		
int velocidad_motor_izquierdo, velocidad_motor_derecho;

//VARIABLES PID

    float Kp = 6, Kpi_p = 3, Kpi_i = 2;  
    float error_p, error_pi, integral;
    float PPI_angulo;

void setup()
{
	 	Serial.begin(115200);
    		Wire.begin(); 
	//Adjuntar motores, programar ESC's y habilitar sensores
			
		...
} 
void loop()
{
	//Medida ángulo
		...
	 angulo_x = 0.95*(angulo_x + dps_x*DT) + 0.05*angulo_acelerometro_x;	
	 
	//PPI
		 
	  error_p = ANGULO_REFERENCIA - angulo_x; 
    error_pi = Kp*error_p - dps_x;
    integral+=(error_pi*DT);
       
    PPI_angulo = Kpi_p*error_pi + Kpi_i*integral;
 
	//Control motores
	
	 velocidad_motor_izquierdo = Throttle_Motor_Izquierdo + PPI_angulo;
     velocidad_motor_derecho   = Throttle_Motor_Derecho - PPI_angulo;
     
     //El resto igual que en el PID
     
     .....
    
  
}
\end{lstlisting}

A partir de la línea 50 está la implementación del controlador, primero se calcula el error de la salida en grados y después a ese error multiplicado por la constante $K_p$ se le resta la salida en grados por segundo. El resultado de la estabilización con este controlador para distintos valores de las constantes se muestra en la figura \ref{fig:escalonppi}. 


\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonppi2}
    \caption{K_p = 3 - K_{pi\_p} = 4 - K_{pi\_i} = 2.}
  \end{subfigure}  
      \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonPPI}
    \caption{K_p = 4 - K{pi\_p} = 5 - K{pi\_i} = 2.}
  \end{subfigure}
  \caption{Respuesta del sistema para controlador PPI.}
  \label{fig:escalonppi}
\end{figure}


A simple vista con este controlador se ha mejorar la velocidad de respuesta y el ruido en régimen permanente es menor. Además en el caso (a) el error en régimen permanente antes del escalón es prácticamente nulo, siendo el error máximo de 1º en un solo instante. El ruido en régimen permanente se muestra en detalle en la figura \ref{fig:errorppi}.


\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonppi2detalle}
    \caption{K_p = 3 - K_{pi\_p} = 4 - K_{pi\_i} = 2.}
  \end{subfigure}  
      \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonppidetalle}
    \caption{K_p = 4 - K{pi\_p} = 5 - K{pi\_i} = 2.}
  \end{subfigure}
  \caption{Detalle del ruido presente en la respuesta en régimen permanente del controlador PPI.}
  \label{fig:errorppi}
\end{figure}

Con el ajuste de las constantes se ha conseguido mejorar la velocidad de respuesta, llegando antes en el caso (a) al régimen permanente y con un máximo sobreimpulso menor. Los parámetros en régimen transitorio de este controlador son:

\newpage

\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Parámetros en régimen transitorio PPI.}
  \label{table11}
  \begin{center}
            \begin{tabular}{|c|c|c|}
      \hline
      \rowcolor{LightBlue2} Parámetro & Caso (a) & Caso (b) \\
      \hline
      Tiempo de retardo ($t_d$) & 0.83 seg & 1.1 seg\\
      \hline
      Tiempo de subida ($t_r$) & 0.97 seg & 1.2 seg\\
      \hline
      Tiempo de pico ($t_p$) & 1.65 seg  & 1.32 seg\\
      \hline
      Tiempo de establecimiento ($t_{s10\%}$) & 1.83 seg & 9.63 seg\\
      \hline
     Máximo sobreimpulso ($M_p$) & 35º (1.16) & 37º (1.23)\\
      \hline
    \end{tabular}
  \end{center}
\end{table}


\subsection{PIP}
\label{sec:controladorpip}

Este controlador es muy similar al implementado en el apartado anterior, pero ahora se realiza un controlador proporcional integral para los grados y un controlador proporcional para la velocidad angular. El esquema de este regulador se muestra en la figura \ref{fig:pip}


 \begin{figure}[!h]
  \centering
    \includegraphics[scale=0.8]{images/PIPdesglose}
  \caption{Esquema del controlador PIP.}
  \label{fig:pip}
\end{figure}

Este controlador consiste en realimentar la salida en grados aplicándole al error un controlador proporcional y realimentar la salida de la planta en grados por segundo y al error aplicarle un controlador proporcional integral. La implementación de este controlador se realiza mediante el código \ref{cod:ejemplo123456}.


\begin{lstlisting}[caption=Implementación del PID., label=cod:ejemplo123456,style=Cnice]
#include <Servo.h>  							
#include <Wire.h>
#include <LSM303.h>
#include <L3G.h>

#define DT 0.03 
#define ANGULO_REFERENCIA = 0; //Ángulo al que se quiere estabilizar el brazo

#define MAX_SIGNAL                 2000
#define MIN_SIGNAL                 700 

#define MAX_VEL                    1500	
#define MIN_VEL                    1000 

#define MOTOR_IZQUIERDO_PIN        9
#define MOTOR_DERECHO_PIN          10    

#define Throttle_Motor_Izquierdo   1300   //Velocidad de los motores si el error es 0
#define Throttle_Motor_Derecho     1300 

double angulo_x;

//VARIABLES MOTORES

Servo motorizquierdo, motorderecho;		
int velocidad_motor_izquierdo, velocidad_motor_derecho;

//VARIABLES PID

    float Kpi_p = 3, Kpi_i = 1,  Kp_p = 4;  
    float error_pi, valor_PI, integral_pi, error_p;
    float PIP_angulo;

void setup()
{
	 	Serial.begin(115200);
    		Wire.begin(); 
	//Adjuntar motores, programar ESC's y habilitar sensores
			
		...
} 
void loop()
{
	//Medida ángulo
		...
	 angulo_x = 0.95*(angulo_x + dps_x*DT) + 0.05*angulo_acelerometro_x;	
	 
	//PIP
		 
	  error_pi = ANGULO_REFERENCIA - angulo_x; 
    integral_pi+=(error_pi*DT);
    valor_PI = Kpi_p*error_pi + Kpi_i*integral_pi;
    error_p = valor_PI - dps_x;
    
    PIP_angulo = Kp_p*error_p;
 
	//Control motores
	
	 velocidad_motor_izquierdo = Throttle_Motor_Izquierdo + PIP_angulo;
     velocidad_motor_derecho   = Throttle_Motor_Derecho - PIP_angulo;
     
     //El resto igual que en el PID
     
     ..... 
  
}
\end{lstlisting}

A partir de la línea 50 está la implementación del controlador, primero se calcula el error de la salida en grados y después de aplicarle a ese error el controlador proporcional integral se le resta la salida en grados por segundo. El resultado de la estabilización con este controlador para distintos valores de las constantes se muestra en la figura \ref{fig:escalonpip}. 


\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonpip}
    \caption{K_{pi\_p} = 5 - K_{pi\_i} = 2 - K_{p\_p} = 4.}
  \end{subfigure}  
      \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonpip2}
    \caption{K_{pi\_p} = 3 - K_{pi\_i} = 2 - K_{p\_p} = 2.}
  \end{subfigure}
  \caption{Respuesta del sistema para controlador PIP.}
  \label{fig:escalonpip}
\end{figure}

A simple vista con este controlador se consigue un máximo sobreimpulso reducido y una alta velocidad de respuesta, sin embargo en el caso (b) el error en régimen permanente es elevado.  El error en régimen permanente se muestra en detalle en la figura \ref{fig:errorpip}.


\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonpipdetalle}
    \caption{K_{pi\_p} = 5 - K_{pi\_i} = 2 - K_{p\_p} = 4.}
  \end{subfigure}  
      \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/respuestaescalonpip2detalle}
    \caption{K_{pi\_p} = 3 - K_{pi\_i} = 2 - K_{p\_p} = 2.}
  \end{subfigure}
  \caption{Detalle del ruido presente en la respuesta en régimen permanente del controlador PIP.}
  \label{fig:errorpip}
\end{figure}

En este caso con este ajuste de las constantes no se ha conseguido variar mucho la respuesta del sistema, teniendo en ambos casos similares características. 
\newpage
\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Parámetros en régimen transitorio PIP.}
  \label{table11234}
  \begin{center}
            \begin{tabular}{|c|c|c|}
      \hline
      \rowcolor{LightBlue2} Parámetro & Caso (a) & Caso (b) \\
      \hline
      Tiempo de retardo ($t_d$) & 0.93 seg & 1.1 seg\\
      \hline
      Tiempo de subida ($t_r$) & 1.07 seg & 1.08 seg\\
      \hline
      Tiempo de pico ($t_p$) & 2.19 seg  & 1.23 seg\\
      \hline
      Tiempo de establecimiento ($t_{s10\%}$) & 10.95 seg & 12.09 seg\\
      \hline
     Máximo sobreimpulso ($M_p$) & 36º (1.12) & 36º (1.2)\\
      \hline
    \end{tabular}
  \end{center}
\end{table}




\subsection{PIDPID}
\label{sec:controladorpidpid}

En este controlador vuelve a haber dos bucles de realimentación y a ambos errores se les aplica un controlador PID. El esquema de este regulador se muestra en la figura \ref{fig:pidpid}


 \begin{figure}[!h]
  \centering
    \includegraphics[scale=0.8]{images/PIDPIDdesglose}
  \caption{Esquema del controlador PIDPID.}
  \label{fig:pidpid}
\end{figure}

La implementación de este controlador se realiza mediante el código \ref{cod:ejemplo12345678}.


\begin{lstlisting}[caption=Implementación del PID., label=cod:ejemplo12345678,style=Cnice]
#include <Servo.h>  							
#include <Wire.h>
#include <LSM303.h>
#include <L3G.h>

#define DT 0.03 
#define ANGULO_REFERENCIA = 0; //Ángulo al que se quiere estabilizar el brazo

#define MAX_SIGNAL                 2000
#define MIN_SIGNAL                 700 
#define MAX_VEL                    1500	
#define MIN_VEL                    1000 

#define MOTOR_IZQUIERDO_PIN        9
#define MOTOR_DERECHO_PIN          10    

#define Throttle_Motor_Izquierdo   1300   //Velocidad de los motores si el error es 0
#define Throttle_Motor_Derecho     1300 

double angulo_x;

//VARIABLES MOTORES

Servo motorizquierdo, motorderecho;		
int velocidad_motor_izquierdo, velocidad_motor_derecho;

//VARIABLES PID

    float Kp1 = 8, Kp2 = 8, Ki1 = 4, Ki2 = 5, Kd1 = 3, Kd2 = 1;  
   	float error_PID1, error_pasado_PID1, error_PID2, error_pasado_PID2;
    float derivativo_PID1, integral_PID1, derivativo_PID2, integral_PID2;
    float PID1, PIDPID_angulo;

void setup()
{
	 	Serial.begin(115200);
    		Wire.begin(); 
	//Adjuntar motores, programar ESC's y habilitar sensores
		...
} 
void loop()
{
	//Medida ángulo
		...
	 angulo_x = 0.95*(angulo_x + dps_x*DT) + 0.05*angulo_acelerometro_x;	
		 
	 //PID del angulo
    
    		error_PID1 = ANGULO_REFERENCIA - angulo_x; 
    		integral_PID1+=(error_PID1*DT);
    		derivativo_PID1 = (error_PID1-error_pasado_PID1)/DT;

    		PID1 = Kp1*error_PID1 + Ki1*integral_PID1 + Kd1*derivativo_PID1;

    //PID de la velocidad angular
    
    		error_PID2 = PID1 - dps_x; 
    		integral_PID2+=(error_PID2*DT);
    		derivativo_PID2 = (error_PID2-error_pasado_PID2)/DT;
    		
    		PIDPID_angulo = Kp2*error_PID2 + Ki2*integral_PID2 + Kd2*derivativo_PID2;
  	 
	//Control motores
	
	 velocidad_motor_izquierdo = Throttle_Motor_Izquierdo + PIDPID_angulo;
     velocidad_motor_derecho   = Throttle_Motor_Derecho - PIDPID_angulo;
   //El resto igual que en el PID   
     		..... 
}
\end{lstlisting}

El resultado de la estabilización con este controlador sólo se va a mostrar para un valor de las constantes, la sintonización de este controlador resulta compleja debido al elevado número de constantes que hay que variar. 

\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.6]{images/respuestaescalonPIDPID}
  \caption{Respuesta del sistema para controlador PIDPID.}
  \label{fig:escalonPIDPID}
\end{figure}

Los valores de las constantes utilizados para la respuesta obtenida son los que hay en la línea 29 del código \ref{cod:ejemplo12345678}. El error en régimen permanente es elevado debido al ruido introducido por los motores, que alternan entre la velocidad máxima y mínima constantemente sin mantener la posición estable en ningún momento.

\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.6]{images/respuestaescalonPIDPIDdetalle}
  \caption{Detalle del ruido presente en la respuesta en régimen permanente del controlador PIDPID.}
  \label{fig:errorPIDPID}
\end{figure}

\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Parámetros en régimen transitorio PIDPID.}
  \label{table1123456}
  \begin{center}
            \begin{tabular}{|c|c|}
      \hline
      \rowcolor{LightBlue2} Parámetro & Valores  \\
      \hline
      Tiempo de retardo ($t_d$) & 1.12 seg \\
      \hline
      Tiempo de subida ($t_r$) & 1.26 seg \\
      \hline
      Tiempo de pico ($t_p$) & 2.43 seg  \\
      \hline
      Tiempo de establecimiento ($t_{s10\%}$) & 16.44 seg \\
      \hline
     Máximo sobreimpulso ($M_p$) & 44º (1.46) \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

El aumento del número de constantes a sintonizar hace que obtener buenos resultados con este controlador sea complicado y no es aconsejable su uso, pues con controladores menos complejos se obtienen mejores resultados con un menor tiempo de cómputo y una menor capacidad de cómputo, lo que es importante en una aplicación como esta en la que no se dispone de un procesador con mucha potencia.

\subsection{Comparativa}
\label{sec:comparativacontroladores}

Habiendo implementado cada controlador de los arriba comentados y obtenido su respuesta ante un escalón se van a mostrar los mejores resultados de cada controlador para comprobar cuál de todos ellos es el más adecuado.

\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Parámetros en régimen transitorio PIDPID.}
  \label{table1123456}
  \begin{center}
            \begin{tabular}{|c|c|c|c|c|}
      \hline
      \rowcolor{LightBlue2} Parámetro/Controlador & PID & PPI & PIP & PIDPID   \\
      \hline
      Mejor caso & (b)  & (a) & (a) & - \\
      \hline
      Tiempo de retardo ($t_d$) & 1.2 seg & 0.83 seg & 0.93 seg & 1.12 seg  \\
      \hline
      Tiempo de subida ($t_r$) & 5.4 seg  & 0.97 seg & 1.07 seg & 1.26 seg\\
      \hline
      Tiempo de pico ($t_p$) & 6.59 seg & 1.65 seg & 2.19 seg & 2.43 seg  \\
      \hline
      Tiempo de establecimiento ($t_{s10\%}$) & 4.19 seg & 1.83 seg & 10.95 seg &16.44 seg  \\
      \hline
     Máximo sobreimpulso ($M_p$) & 31º (1.03) &  35º (1.16) & 36º (1.12) & 44º (1.46)   \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

En el caso del controlador PID el tiempo de pico es superior al tiempo de establecimiento porque el sistema es subamortiguado, es decir, la salida no llega a superar el ángulo de referencia durante el régimen transitorio, pero sí en algunos momentos del régimen permanente, como se puede observar en la figura \ref{fig:escalonpid}. La elección del controlador más adecuado depende de la aplicación para la que se necesite, si se necesita buena {\bf precisión} el mejor controlador es el {\bf PID}, su error en régimen permanente es pequeño y no tiene sobreimpulso en régimen transitorio. Si lo que se necesita es alta {\bf velocidad de respuesta} el controlador más adecuado es el {\bf PPI}, con él se obtiene una respuesta el doble de rápida que con el segundo controlador más rápido, siendo el régimen transitorio muy corto. Como ya se ha comentado en la sección \ref{sec:controladorpidpid}, el controlador PIDPID no es una buena opción pues su sintonización es complicada por tener el doble de constantes a establecer que el resto de controladores.

\newpage
\subsection{Eliminación previa de errores}
\label{sec:eliminacionerrores}

En este apartado se van a comentar dos errores que han surgido durante las pruebas realizadas con el brazo. Debido a estas pruebas se han encontrado maneras de conseguir que el sistema se vuelva inestable, sin embargo con unas pocas líneas de código se pueden eliminar estos errores.

\subsubsection{Anti-Windup}
\label{sec:antiwindup}

Como se explica en \cite{windup} el windup es un fenómeno que ocurre cuando la salida de un controlador proporcional integral está saturado, resultando en mal funcionamiento e incluso inestabilidad. Al controlar la velocidad de un motor, un cambio brusco en la velocidad puede provocar que la corriente generada por el controlador electrónico de velocidad llegue a su valor máximo, que viene determinado por el protector del controlador, la saturación magnética y el sobrecalentamiento del motor.\\
\\
Este efecto se ha conseguido durante las pruebas sujetando el brazo en una posición alejada de la posición de referencia, provocando así que el factor integral del PID esté sumando constantemente y se acumule durante unas decenas de segundos. Al volver a soltar el brazo la suma del integral es muy elevada y el error a corregir por el controlador es mayor que el real, haciendo que l brazo no vuelva a estabilizarse hasta que el integral tiene un valor pequeño. Esto puede pasar en un caso real con una fuerza externa como por ejemplo el viento, si hay una fuerte ráfaga de viento y provoca que el aparato salga de la posición de referencia se produce este efecto. Para eliminar este fenómeno sólo hay que limitar el valor del parámetro integral del controlador, como se muestra en el código \ref{cod:12341234}. El código mostrado corresponde al controlador PID, pero se aplica al resto de controladores que incluyan un integral de la misma manera. A este controlador se le puede denominar controlador Anti-Windup, pues no le afecta este fenómeno.


\begin{lstlisting}[caption=Anti-Windup., label=cod:12341234,style=Cnice]

#define MAXIMO_INTEGRAL 200
...
void loop()
{
	 
	//PID
		 
	 error = ANGULO_REFERENCIA - angulo_x; 
    	 integral+=(error*DT);
    	 derivativo = (error-error_pasado)/DT;
    	 PID_angulo = Kp*error + Ki*integral + Kd*derivativo;

	
		if(integral > MAXIMO_INTEGRAL)       
        integral = MAXIMO_INTEGRAL;
    else if(integral < -MAXIMO_INTEGRAL)
        integral = -MAXIMO_INTEGRAL;
        
	...
}
\end{lstlisting}

De la línea 15 a la línea 18 se observa la implementación del Anti-Windup. Hay que limitarlo para todo el margen de valores de la variable integral, puesto que la variable error puede ser positiva o negativa se limita para valores positivos y para valores negativos. El valor de \textit{MAXIMO\_INTEGRAL} se ha establecido mediante pruebas, comprobando que con valores mayores se sigue produciendo el fenómeno wind-up y con valores menores se empeora la estabilización del brazo.


\subsubsection{Limitación de la velocidad de los motores}
\label{sec:limitacionmotores}

La velocidad de los motores se puede variar mediante el ESC desde un mínimo de una señal de 1 ms hasta un máximo de una señal de 2 ms para que estén girando y no se paren. Sin embargo, la fuente de alimentación disponible entrega una corriente limitada y reducida. Debido a la forma de implementar el control de los motores si no se limita su velocidad y el error es elevado se puede dar la situación de que uno de los motores gire a un valor por debajo del mínimo y se pare y el otro gire a una velocidad mayor que la máxima y pueda llegar a romperse. Además se ha comprobado mediante las pruebas que si uno de los motores gira a máxima velocidad y el otro a mínima velocidad la fuente no es capaz de entregar la corriente necesaria y los motores no giran a la velocidad adecuada para estabilizar el brazo, provocando un mal funcionamiento. Para solucionar este problema se debe limitar la velocidad de los motores antes de mandar la señal al ESC, como se muestra en el código \ref{cod:1}.


\begin{lstlisting}[caption=Limitación de la velocidad de los motores., label=cod:1,style=Cnice]

...
#define MAX_VEL                    1500	
#define MIN_VEL                    1000 

#define MOTOR_IZQUIERDO_PIN        9
#define MOTOR_DERECHO_PIN          10    

#define Throttle_Motor_Izquierdo   1300   //Velocidad de los motores si el error es 0
#define Throttle_Motor_Derecho     1300 

double angulo_y

//VARIABLES MOTORES

Servo motorizquierdo, motorderecho;		
int velocidad_motor_izquierdo, velocidad_motor_derecho;

...


void loop()
{
	...
	 
	//PID
		 
	 error = ANGULO_REFERENCIA - angulo_x; 
    	 integral+=(error*DT);
    	 derivativo = (error-error_pasado)/DT;
    	 PID_angulo = Kp*error + Ki*integral + Kd*derivativo;

	//Control motores
	
		 velocidad_motor_izquierdo = Throttle_Motor_Izquierdo + PID_angulo;
     velocidad_motor_derecho   = Throttle_Motor_Derecho - PID_angulo;
     
      velocidad_motor_izquierdo = (velocidad_motor_izquierdo > MAX_VEL) ? MAX_VEL:velocidad_motor_izquierdo;
     velocidad_motor_izquierdo = (velocidad_motor_izquierdo < MIN_VEL) ? MIN_VEL:velocidad_motor_izquierdo; 
     
     velocidad_motor_derecho = (velocidad_motor_derecho > MAX_VEL) ? MAX_VEL:velocidad_motor_derecho;
     velocidad_motor_derecho = (velocidad_motor_derecho < MIN_VEL) ? MIN_VEL:velocidad_motor_derecho;
     
     motorizquierdo.writeMicroseconds(velocidad_motor_izquierdo);
     motorderecho.writeMicroseconds(velocidad_motor_derecho);
     
     error_pasado = error;	//Para calcular el derivativo 
}
\end{lstlisting}
De la línea 38 a la línea 43 se muestra cómo se limita la velocidad de los motores. Si no se limita su valor la velocidad de los motores asignada en las líneas 35 y 36 pueden salirse de los valores mínimo y máximo y el sistema dejaría de ser estable.



\part{Manejo del brazo mediante LabView}
\label{part:labview}

\chapter{Manejo del brazo mediante LabView}
\label{chapter:labview}

\section{Introducción}
\label{sec:introduccionlabview}

Hasta esta parte del trabajo se han explicado todos los pasos necesarios para conseguir una buena estabilización del brazo, desde cómo obtener una estimación precisa del ángulo hasta cómo implementar los controladores para estabilizar el brazo en la posición deseada. Para poder realizar pruebas es necesario hacer un programa mediante el que se pueda variar el ángulo de referencia y las constantes de los controladores. Esto se puede hacer mandando comandos mediante el puerto serie del Arduino y mostrándolos en el monitor serie disponible en la IDE de Arduino pero es poco intuitiva y hay que actualizar los datos mostrados por pantalla a baja frecuencia para que sean visibles. Existe una aplicación de National Instruments \cite{paginani} para ciencia e ingeniería, llamada LabView, que es un entorno de desarrollo gráfico que permite controlar sistemas de una forma más visual y reducir el tiempo empleado para las pruebas. En este apartado se va a explicar brevemente los pasos necesarios para desarrollar un programa en LabView que muestre los resultados por pantalla y recopile datos para después obtener las gráficas en Matlab.

\section{Programación del Arduino}
\label{sec:programacionarduino}

El primer paso es programar el Arduino las entradas que se van a usar para variar los valores del ángulo de referencia y de las constantes de los controladores. La solución implementada es leer el puerto serie y asociar ciertos caracteres incrementos o decrementos de los valores, como se muestra en el código \ref{cod:ej}.

\begin{lstlisting}[caption=Programación en Arduino para variar referencia y constantes., label=cod:ej,style=Cnice]
#define ANGULO_REF_MAX  70
#define ANGULO_REF_MIN -70
float INCREMENTO_ANGULO_POSITIVO = 1;
float INCREMENTO_ANGULO_NEGATIVO = -1;
char val;

void serialEvent(){      
  
  if( Serial.available() )    // si hay dato y el puerto lo lee
      val = Serial.read();    // lee y almacena el dato en 'val'
   
    switch (val){
      
      case '+':
        ANGULO_REFERENCIA += INCREMENTO_ANGULO_POSITIVO;
        if (ANGULO_REFERENCIA > ANGULO_REF_MAX)
              ANGULO_REFERENCIA -= INCREMENTO_ANGULO_POSITIVO;
      break;
      
      case '-':
        ANGULO_REFERENCIA += INCREMENTO_ANGULO_NEGATIVO;
        if (ANGULO_REFERENCIA < ANGULO_REF_MIN)
              ANGULO_REFERENCIA -= INCREMENTO_ANGULO_NEGATIVO;
      break;

      case 'R':
        INCREMENTO_ANGULO_POSITIVO+=1;
        INCREMENTO_ANGULO_NEGATIVO-=1;
      break;
      
      case 'r':
        INCREMENTO_ANGULO_POSITIVO-=1;
        INCREMENTO_ANGULO_NEGATIVO+=1;
      break;
      
     case 'd':
        Kd-=1;
      break;
      
      case 'D':
        Kd+=1;
      break;
      
      case 'i':
        Ki-=1;
      break;
      
      case 'I':
        Ki+=1;
      break;
      
      case 'p':
        Kp-=1;
      break;
      
      case 'P':
        Kp+=1;
      break;
      
    }  
}
\end{lstlisting}

La limitación del ángulo se implementa por seguridad por código además de físicamente con la barra horizontal entre las dos vigas que sujetan el brazo. La función \textit{serialEvent()} es un evento que ocurre cuando un dato llega al puerto serie a través de RX. El Arduino lo comprueba cada iteración del bucle principal. Para cada acción se ha asociado un carácter en minúsculas y el mismo carácter en mayúsculas. Por ejemplo, si se pulsa D se incrementa en uno la constante $K_d$ . En el caso de pulsar R lo que se hace es variar el tamaño del escalón de referencia que se incrementará o decrementará al pulsar + o -, es decir, si se pulsa R 4 veces la variable \textit{INCREMENTO\_ANGULO\_POSITIVO} valdrá 5 y la próxima vez que se pulse + el ángulo de referencia será 5º mayor. 

\newpage

Mediante el código \ref{cod:ej} se ha mostrado cómo implementar la entrada de datos, pero también es necesario mostrar los resultados por pantalla. La única manera de comunicación entre la aplicación que se desarrollará en LabView y el programa cargado en Arduino es el puerto serie, por lo tanto para mostrar los resultados hay que escribir desde el programa de Arduino en el puerto serie los valores y leerlos en LabView.


\begin{lstlisting}[caption=Escritura de datos, label=cod:ej12,style=Cnice]

void Imprimir_LabView(){

   Serial.print((int) angulo_x); 
   Serial.print("\t");

   Serial.print((int) velocidad_motor_izquierdo); 
   Serial.print("\t");

   Serial.print((int) velocidad_motor_derecho); 
   Serial.print("\t\n");
}
\end{lstlisting}


Debido a la gran cantidad de código que se va acumulando para poder estabilizar el brazo es conveniente organizarlo en pestañas, disponibles en la IDE del Arduino. En cada pestaña se pueden programar las funciones asociadas a cada parte del trabajo, una para el cálculo del PID, otra para la estimación del ángulo...


\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/pestanas}
  \caption{Distribución en pestañas del programa implementado para el controlador PID.}
  \label{fig:pestanas}
\end{figure}


\section{Desarrollo en LabView}
\label{sec:desarrollolabview}

Habiendo programado los caracteres que realizarán las modificaciones sólo queda realizar el programa en LabView. Para poder ejecutar el programa desde LabView se debe abrir una comunicación serie igual que si se hiciese mediante Arduino. Como se indica en la página de National Instruments \cite{pag}, para tener acceso al puerto serie usando LabView se debe iniciar una sesión VISA y configurarla con los mismos parámetros que en el Arduino, el baud rate y el carácter de fin de lectura, que en Arduino viene por defecto como 0xA, que es el retorno de carro (\textbackslash n). Una vez configurada la sesión VISA empezará la ejecución del programa cargado en el Arduino, por lo tanto hay que programar los mismos pasos seguidos en Arduino desde LabView, que son escribir un carácter cualquiera en el puerto serie de Arduino para la calibración del ESC y después comienza el bucle principal. 

\newpage

\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{images/VISA}
    \caption{Configuración sesión VISA.}
  \end{subfigure}  
      \begin{subfigure}{0.34\textwidth}
    \includegraphics[width=\textwidth]{images/escribircaracter}
    \caption{Escritura de carácter.}
  \end{subfigure}
  \caption{Pasos para que comience el bucle principal.}
  \label{fig:sesionvisa}
\end{figure}

Ya se puede pasar al bucle principal para modificar los valores de las constantes y del ángulo de referencia. La duración del bucle de LabView tiene que ser la misma que la del bucle principal del Arduino, tienen que ser síncronos. En LabView se debe estar leyendo el puerto serie cada iteración para mostrar los resultados por pantalla y se deben programar botones para realizar las modificaciones, todo ello metido dentro de un bucle \textit{while} que acabe mediante un botón de Stop. Una captura de la interfaz implementada se muestra en la figura \ref{fig:interfaz}.

\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/Interfaz}
  \caption{Interfaz gráfica desarrollada en LabView.}
  \label{fig:interfaz}
\end{figure}

Los elementos que se han programado en la interfaz son:

\begin{itemize}

	\item {\bf Botón para modificar el ángulo de referencia}: para programarlo hay que enviar el carácter correspondiente por el puerto serie, que es + para los incrementos y - para los decrementos.
	
	\item {\bf Botón para modificar el tamaño del escalón del ángulo de referencia}: se debe escribir por el puerto serie el carácter correspondiente, que es R para incrementos y r para decrementos.
	
	\item {\bf Botones para modificar las constantes del controlador}: estos controles son muy útiles para modificar el tipo de respuesta del controlador sin tener que recurrir a la ejecución del programa cada vez que se quiera modificar el valor de estas constantes.
	
	\item {\bf Botón para activar/desactivar el \textit{datalog}}: el \textit{datalog} consiste en escribir datos en un fichero para su posterior análisis. En este trabajo se escriben en un fichero \textit{.txt} el ángulo medido, el ángulo de referencia y el instante de tiempo para cada muestra con el fin de obtener una representación en Matlab.
	
	\item {\bf Indicadores de la velocidad de los motores}: ya que en la sección \ref{sec:programacionarduino} se ha mostrado cómo programar en Arduino la escritura por el puerto serie de los valores de los motores, en LabView se debe leer el puerto serie cada iteración del bucle y se tiene el valor de la velocidad de cada motor.
	
	\item {\bf Indicador del ángulo medido}: también llega por el puerto serie, por lo tanto se debe leer el puerto serie y asignar el valor leído al indicador.

	\item {\bf Gráfica que representa en tiempo real el ángulo medido y el ángulo de referencia}:	mediante esta gráfica se observa el tipo de respuesta del sistema en tiempo real, aunque para posteriores análisis como tiempo de establecimiento, máximo sobreimpulso, etc., se usará Matlab es útil para modificar los valores de las constantes hasta conseguir la respuesta deseada.

\end{itemize}

Para finalizar con este apartado se va a mostrar una secuencia de imágenes en las que se ha ejecutado el programa con el controlador PID variando el ángulo de referencia, el tamaño del escalón del ángulo de referencia y, por último, las constantes del controlador. El orden de la secuencia de imágenes de la figura \ref{fig:secuencia} es de izquierda a derecha y de arriba a abajo. 

\begin{figure}[!h] 
\centering
\begin{tabular}{ccc}
  \includegraphics[scale=0.1]{images/secuencia1} & \includegraphics[scale=0.1]{images/secuencia2}&\includegraphics[scale=0.1]{images/secuencia3}\\
 
  \includegraphics[scale=0.1]{images/secuencia4} & \includegraphics[scale=0.1]{images/secuencia5}&\includegraphics[scale=0.1]{images/secuencia6}\\
 
  \includegraphics[scale=0.1]{images/secuencia7} & \includegraphics[scale=0.1]{images/secuencia8}&\includegraphics[scale=0.1]{images/secuencia9}\\
 
 \end{tabular}
 \caption{Secuencia de imágenes de la ejecución del programa con el controlador PID.}
 \label{fig:secuencia}
 
 \end{figure}
 
 
 \part{Conclusiones y trabajo futuro}
\label{part:conclusiones}

\chapter{Conclusiones y trabajo futuro}
\label{chapter:conclusiones}

\section{Conclusiones}
\label{sec:conclusiones}

El trabajo llevado a cabo ha requerido conocimientos de diversas ramas, utilizando conceptos ya estudiados a lo largo de la carrera y teniendo que realizar un estudio de algunos temas a partir de otros artículos de investigación y libros. En la figura \ref{fig:flujo} se muestra un diagrama de los pasos llevados a cabo para realizar el proyecto.

\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/diagramaflujo}
  \caption{Diagrama del sistema.}
  \label{fig:flujo}
\end{figure}

Para llevar a cabo este proyecto se han hecho varias tareas de diversos ámbitos:

\begin{itemize}

	\item {\bf Programas para la estimación del ángulo}: ha sido necesario desarrollar programas propios para poder obtener una estimación del ángulo de los sensores utilizados, algunos algoritmos se han tomado como referencia de la bibliografía pero el programa ha sido desarrollado desde cero.
	
	\item {\bf Programa para regular la velocidad de los motores}: también se han hecho programas para variar la velocidad de los motores mediante el ESC.
	
	\item {\bf Controladores}: cada controlador ha requerido un programa independiente y se han realizado pruebas con cada uno de ellos.
	
	\item {\bf Scripts Matlab}: ha sido necesario usar esta herramienta para obtener gráficas de los resultados de la respuesta del sistema.
	
	\item {\bf Interfaz LabView}: el desarrollo de una aplicación para manejar el brazo y realizar pruebas con él es imprescindible, una buena opción es realizar esta aplicación con LabView. El aprendizaje para la programación en LabView ha sido rápido y los resultados son muy buenos.
	
	\item {\bf Montaje de la estructura}: partiendo de un tablero de madera se han cortado las piezas necesarias para montar la estructura y se ha ensamblado obteniendo la estructura mostrada en la figura \ref{fig:estructuraensamblada}.

	\item {\bf Conexionado del circuito}: el sistema constaba de dos circuitos independientes, uno de potencia que alimentaba los motores mediante la batería, y uno de control mediante el que se mandaban las señales de control a los motores y se leían los datos de los sensores.

\end{itemize}

Llevar a cabo todos estos pasos ha requerido un aprendizaje en las materias de control, electrónica, electricidad y programación. Resulta muy útil aplicar en la práctica conceptos estudiados teóricamente para comprobar las dificultades que se presentan a la hora de implementar un sistema real. Estas dific


\section{Trabajo futuro}
\label{sec:trabajofuturo}

En este apartado se van a comentar algunas mejoras que se pueden hacer a partir del trabajo realizado en este TFG.

\begin{itemize}

	\item {\bf Identificación del modelo de la planta}: si se obtiene el modelo de la planta se pueden realizar simulaciones con la herramienta \textit{Simulink} de Matlab y se puede realizar una mejor acción de control mediante la obtención de la respuesta en frecuencia, del lugar de las raíces...
	
	\item {\bf Añadir un segundo eje y eliminar las barras verticales}: si se eliminan las barras verticales y se añade un segundo eje perpendicular se construye un cuadricóptero, siendo más interesante puesto que se puede controlar el vuelo.
	
	\item {\bf Manejo mediante radiofrecuencia}: si se le añade un receptor/emisor de radiofrecuencia al aparato se puede controlar el ángulo mediante un mando a distancia de forma inalámbrica, este requisito se hace imprescindible si se quiere construir un cuadricóptero.
	
	\item {\bf Manejo mediante Wi-Fi}: si se añade un módulo Wi-Fi a la placa se puede crear una red mediante la que controlar inalámbricamente el brazo desde el ordenador, sin necesidad de tener conectado el cable USB todo el tiempo que se quieran realizar pruebas.
	

\end{itemize}


 \part{Diagramas}
\label{part:diagramas}

\chapter{Diagramas}
\label{chapter:diagramas}

\subsection{Diagrama de flujo del sistema}
\label{sec:diagramaflujo}

\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.45]{images/diagramaflujo1}
  \caption{Diagrama de flujo del sistema.}
  \label{fig:diagramaflujo}
\end{figure}

\subsection{Diagrama general del sistema}
\label{sec:diagramageneral}

\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/diagramaflujo}
  \caption{Diagrama general del sistema.}
  \label{fig:diagramageneral}
\end{figure}


\subsection{Esquema de la conexión de los motores y el sensor}
\label{sec:diagramaconexion}

\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/circuitofritzing}
  \caption{Esquema de la conexión de un motor.}
  \label{fig:diagramaconexion}
\end{figure}

\newpage



\subsection{Diagramas de bloques de los controladores}
\label{sec:diagramascontroladores}

\subsubsection{PID}

\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/PIDdesglose1}
  \caption{Diagrama de bloques del controlador PID.}
  \label{fig:diagramaPID}
\end{figure}


\subsubsection{PPI}
\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/PPIdesglose1}
  \caption{Diagrama de bloques del controlador PPI.}
  \label{fig:diagramaPPI}
\end{figure}

\subsubsection{PIP}
\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/PIPdesglose}
  \caption{Diagrama de bloques del controlador PIP.}
  \label{fig:diagramaPIP}
\end{figure}

\subsubsection{PIDPID}
\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/PIDPIDdesglose}
  \caption{Diagrama de bloques del controlador PIDPID.}
  \label{fig:diagramaPIDPID}
\end{figure}


\subsection{Diagramas de la estructura}
\label{sec:diagramasestructura}

\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/BrazoTFG_Vista3D}
  \caption{Representación del objeto en 3D con Autodesk Inventor.}
  \label{fig:diagrama3D}
\end{figure}



\begin{sidewaysfigure}[!h]
		\centering
			\includegraphics[width=\textwidth]{images/BrazoTFG}
			\caption{Vistas de la estructura.}
			\label{fig:diagramasvistasdiedrico}
\end{sidewaysfigure}

\part{Pliego de condiciones}
\label{part:pliegocondiciones}

\chapter{Pliego de condiciones}
\label{chapter:pliegocondiciones}

\subsection{Requisitos de Hardware}
\label{sec:requisitoshardware}

\begin{multicols}{2}

\begin{itemize}



	\item {\bf Microcontrolador Arduino Uno}
	
	\item  {\bf Unidad de de medición inercial (IMU) AltIMU-10}
	
	\item  {\bf PC con puerto USB}
	
	\item  {\bf Fuente de alimentación}
	
	\item {\bf Motores Brushless}
	
	\item {\bf Hélices}
	
	\item {\bf Controladores electrónicos de velocidad (ESC)}
	
	\item {\bf Tablones de madera para ensamblar la estructura}
	
	\item {\bf Placa de prototipos para soldar el circuito}
	

\end{itemize}

\end{multicols}


\subsection{Requisitos de Software}
\label{sec:requisitossoftware}

\begin{multicols}{2}

\begin{itemize}

	\item {\bf Matlab R2015 versión estudiante}
	
	\item {\bf IDE\footnote{Siglas de Integrated Development environment, en español entorno de desarrollo integrado} de Arduino}
	
	\item {\bf Sistema operativo compatible con la IDE de Arduino}
	
	\item  {\bf LabView versión estudiante}
	
	\item {\bf AutoDesk Inventor versión estudiante}	
	
\end{itemize}

\end{multicols}


\part{Presupuesto}
\label{part:presupuesto}

\chapter{Presupuesto}
\label{chapter:presupuesto}

\subsection{Coste del Hardware}
\label{sec:presupuestohardware}
\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Costes Hardware (21\% IVA incluido).}
  \label{table112342345}
  \begin{center}
  \begin{tabu} to \textwidth {|X[c]|X[c]|X[c]|X[c]|} 
            
      \hline
      \rowcolor{LightBlue2} {\bf CONCEPTO}	 & {\bf Precio [\euro /ud]} & {\bf Unidades} & {\bf TOTAL[\euro]}\\
      \hline
      {\bf Arduino Uno} & 24.2 & 1 & 24.2\\
      \hline
     {\bf AltIMU-10} & 24.97 & 1 & 24.97\\
      \hline
      {\bf MacBook Pro} & 1499   & 1 & 1499\\
      \hline
      {\bf Fuente Octek006} & 39.95 & 1 & 39.95\\
      \hline
     {\bf Motor Brushless} & 5.79 & 2 & 11.58\\
      \hline
      {\bf ESC} & 6.90 & 2 & 13.80\\
      \hline
      {\bf Hélice} & 4.97 & 2 & 9.95\\
      \hline
      {\bf Tablero madera} & 10 & 1 & 10\\
      \hline
    {\bf Placa prototipos} & 10 & 1 & 10\\
      \hline
      \multicolumn{3}{|c|}{\bf TOTAL HARDWARE} &      {\bf 1643.45}\\
      \hline
    \end{tabu}
  \end{center}
\end{table}




\subsection{Coste del Software}
\label{sec:presupuestosoftware}
\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Costes Software (21\% IVA incluido).}
  \label{table1123423456}
  \begin{center}
            \begin{tabu} to \textwidth {|X[c]|X[c]|X[c]|X[c]|} 
      \hline
      \rowcolor{LightBlue2} {\bf CONCEPTO}	 & {\bf Precio [\euro /ud]} & {\bf Unidades} & {\bf TOTAL[\euro]}\\
      \hline
       {\bf IDE de Arduino} & 0 & 1 & 0\\
      \hline
       {\bf Matlab estudiante} & 49.99 & 1 & 49.99\\
      \hline
       {\bf LabView estudiante}& 19.99 & 1 & 19.99\\
      \hline
       {\bf Inventor  estudiante}& 19.99 & 1 & 19.99\\
      \hline
       {\bf Mac OS X} & 0 & 1 & 0\\
      \hline
      {\bf TexMaker} & 0 & 1 & 0\\
      \hline
      \multicolumn{3}{|c|}{\bf TOTAL SOFTWARE} &      {\bf 89.97}\\
      \hline
    \end{tabu}
  \end{center}
\end{table}



\subsection{Importe total}
\label{sec:presupuestototal}
\begin{table}[!h]
    \renewcommand{\arraystretch}{1.3}
  \caption{Coste total.}
  \label{table1123423457}
  \begin{center}
           \begin{tabu} to \textwidth {|X[c]|X[c]|} 
      \hline
     \rowcolor{LightBlue2} {\bf CONCEPTO}	 & {\bf COSTE[\euro]}\\
      \hline
      {\bf Hardware} & 4643.5\\
      \hline
       {\bf Software} & 89.97\\
      \hline
      {\bf TOTAL} & {\bf 1733.42}\\
      \hline
    \end{tabu}
  \end{center}
\end{table}


\part{Manual de usuario}
\label{part:manual}

\chapter{Manual de usuario}
\label{chapter:manual}

\section{Introducción}
\label{sec:introduccionmanual}
En este apartado se van a especificar todos los pasos necesarios para poder ejecutar el programa final de LabView de manejo del brazo y estabilizarlo en el ángulo deseado.


\subsection{Subir programa al Arduino}
\label{sec:subirprograma}

El primer paso para poder ejecutar el programa es conectar el Arduino mediante el puerto USB al ordenador y subir el programa que se quiere ejecutar. La carga del programa se hace mediante la IDE de Arduino, disponible en \cite{idearduino},  pulsando el botón que se indica en la figura \ref{fig:cargaprograma}.


\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/cargaprograma}
  \caption{Cargar programa en el Arduino.}
  \label{fig:cargaprograma}
\end{figure}

\newpage

\subsection{Comenzar ejecución}
\label{sec:comienzoejecución}

Con el programa ya cargado en el Arduino ahora se debe comenzar la ejecución del programa. Previo a la ejecución es importante leer las consideraciones del programa escritas en la interfaz para conocer su funcionamiento. Estas consideraciones son:

\begin{enumerate}



	\item {\bf Seleccionar en la sesión VISA el Arduino}: normalmente está seleccionado por defecto pero hay que asegurarse previo a la ejecución de que existe comunicación entre LabView y Arduino.
	
	\item  {\bf Para finalizar el programa pulsar \textit{Stop} y desconectar la fuente de alimentación}: si sólo se pulsa \textit{Stop} el brazo se queda estabilizado en la última posición indicada por el usuario, para que se paren los motores hay que desconectar la fuente de alimentación.
	
	\item  {\bf Los valores del ángulo de referencia y de las constantes del controlador no pueden cambiarse antes de la ejecución del programa}: debido a la forma de comunicación entre LabView y Arduino hasta que no se ejecuta el programa en  LabView no comienza la sesión VISA y no existe comunicación entre la aplicación y Arduino; los valores por defecto coinciden en el programa cargado en Arduino y en la aplicación de LabView, por lo tanto si se cambian en LabView antes de comenzar la ejecución del programa los valores van a ser distintos de los que había por defecto y va a haber un mal funcionamiento.
	


\end{enumerate}

Para comenzar la ejecución del programa en la ventana principal de LabView se debe pulsar el botón ejecutar como se muestra en la figura \ref{fig:botonejecutar}.

\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/ejecutar}
  \caption{Comenzar ejecución.}
  \label{fig:botonejecutar}
\end{figure}

Tras este paso ya ha comenzado la ejecución del programa y ya hay comunicación entre al aplicación de LabView y el Arduino, pues ya se ha abierto el puerto serie. Ahora que ha comenzado el programa cargado en Arduino el siguiente paso aparecerá en un mensaje por pantalla con un botón de \textit{OK}. 

\newpage

\begin{figure}[!h]
  \centering
    \includegraphics[scale=0.3]{images/mensaje}
  \caption{Botón OK.}
  \label{fig:botonejecutar}
\end{figure}

La fuente de alimentación dispone de un interruptor para permitir/cortar el paso de la corriente. Como se indica en el mensaje de la figura \ref{fig:botonejecutar} se debe pulsar el interruptor. Tras pulsar el interruptor se escuchará un sonido proveniente del ESC que indica que se ha encendido, después de ese primer sonido se escuchará otro sonido que indica que la programación del ESC ha entrado en modo \textit{throttle}, que es en la que se quiere trabajar. Después de ese segundo sonido se debe pulsar el botón \textit{OK}.


\begin{figure}[!h]
  \centering
    \includegraphics[width=\textwidth]{images/secuencia2}
  \caption{Ejecución activa.}
  \label{fig:ejecucionactiva}
\end{figure}

La ejecución habrá comenzado, como indica la luz verde de la interfaz, y ya se puede manejar el brazo variando el ángulo de referencia y variando los valores de las constantes del controlador.







\makeatletter{}


\newcommand{\mybibfileOne}{biblio/biblio}
\newcommand{\mybibfileTwo}{biblio/biblio2}

\newcommand{\mybibfiles}{\myreferencespath\mybibfileOne}

\bibliography{book-flatten.bib}
\bibliographystyle{IEEEtran}




                





 
\make

 



\backmatter                                       
\makeatletter{}

\ifthenelse{\equal{\mybookworktype}{TFG}}
{
  \makeatletter{}
\chapter*{ }
\thispagestyle{empty}

\cleartoleftpage
\thispagestyle{empty}

\BgThispage


\begin{tikzpicture}[remember picture,overlay]
    \node[yshift=-5cm] at (current page.north west)
      {
        \begin{tikzpicture}[remember picture, overlay]
          \draw[fill=headingPortadaTFG,headingPortadaTFG] (0,0) rectangle (\paperwidth,5cm);

          \node [yshift=3cm, xshift=0.5\paperwidth, font=\Huge, text centered, midway] {\color{textoHeadingPortadaTFG}\mybookuniversity};
          \node [yshift=2cm, xshift=0.5\paperwidth, font=\Huge, text centered, midway] {\color{textoHeadingPortadaTFG}\mybookschool};

        \end{tikzpicture}
      };
   \end{tikzpicture}


\large
\vspace{20cm}
\begin{center}
  
  \centerline{\includegraphics[height=2.5cm]{uah/01_logo-vA_pant293.pdf}}

\end{center}





 
}
{

}



                     
                                              
\end{document}
